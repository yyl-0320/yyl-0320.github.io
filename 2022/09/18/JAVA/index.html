
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JAVA - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="yyl,"> 
    <meta name="description" content="一.第一段程序12345public class Hello&amp;#123;                            //文件名字要与类名相同    public static void ,"> 
    <meta name="author" content="yyl"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="JAVA - Hexo"/>
    <meta name="twitter:description" content="一.第一段程序12345public class Hello&amp;#123;                            //文件名字要与类名相同    public static void ,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="JAVA - Hexo"/>
    <meta property="og:description" content="一.第一段程序12345public class Hello&amp;#123;                            //文件名字要与类名相同    public static void ,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">JAVA</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">JAVA</h1>
        <div class="stuff">
            <span>九月 18, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="一-第一段程序"><a href="#一-第一段程序" class="headerlink" title="一.第一段程序"></a>一.第一段程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;                            <span class="comment">//文件名字要与类名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">num</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">byte</span> num2=<span class="number">35</span>;      <span class="comment">//字节型      1个字节   -128~127</span></span><br><span class="line">        <span class="type">short</span> num3=<span class="number">50</span>;     <span class="comment">//短整型      2个字节   -32768~32767</span></span><br><span class="line">        <span class="type">int</span> num1=<span class="number">10</span>;       <span class="comment">//整形        4个字节   -2^31~2^31-1</span></span><br><span class="line">        <span class="type">long</span> num4=<span class="number">3000000L</span>;<span class="comment">//长整型      8个字节   -2^63~2^63-1      后面要加L</span></span><br><span class="line">        <span class="type">float</span> numm5=<span class="number">2.5F</span>;  <span class="comment">//单精度浮点数  4个字节   1.4013E-45~3.4028E+38  后边要加F</span></span><br><span class="line">        <span class="type">double</span> num6=<span class="number">1.2</span>;   <span class="comment">//双精度浮点型   8个字节  4.9E-324~1.7977E+308</span></span><br><span class="line">        <span class="type">char</span> zifu1=<span class="string">&#x27;S&#x27;</span>;    <span class="comment">//字符型        2个字节  0~65535</span></span><br><span class="line">        <span class="type">boolean</span> var1=<span class="literal">true</span>; <span class="comment">//布尔类型      一个字节  true false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-数据转换"><a href="#三-数据转换" class="headerlink" title="三.数据转换"></a>三.数据转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">num</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//自动转换:</span></span><br><span class="line">        <span class="type">long</span> num1=<span class="number">100</span>;     <span class="comment">//右边int 类型比左边数据范围小.自动转为long</span></span><br><span class="line">        <span class="type">double</span> num2=<span class="number">2.5F</span>;  <span class="comment">//右边float 类型比左边数据范围小.自动转为double</span></span><br><span class="line">        <span class="type">float</span> num3=<span class="number">30L</span> ;   <span class="comment">//右边long 类型比左边数据范围小.自动转为float</span></span><br><span class="line">        <span class="comment">//强制转换:</span></span><br><span class="line">        <span class="type">int</span> num=(<span class="type">int</span>) <span class="number">100L</span>;<span class="comment">//强制转换</span></span><br><span class="line">        a+=<span class="number">2</span>               <span class="comment">//a=a+2</span></span><br><span class="line">        a&gt;b ? a:b          <span class="comment">//若前边为真则取a;否则取b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-方法的定义与调用"><a href="#四-方法的定义与调用" class="headerlink" title="四.方法的定义与调用"></a>四.方法的定义与调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">four</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        printf();                           <span class="comment">//方法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">()</span>&#123;            <span class="comment">//方法定义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;    <span class="comment">//返回int类型</span></span><br><span class="line">        <span class="type">int</span> sum=a+b;</span><br><span class="line">        <span class="keyword">return</span> sum;                         <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="title function_">sum</span><span class="params">(<span class="type">byte</span> a,<span class="type">byte</span> b)</span>&#123; <span class="comment">//函数重载   只和名字和参数相同 要求名字相同但参数不同(数量,类型等)</span></span><br><span class="line">        <span class="type">byte</span> sum=(<span class="type">byte</span>)(a+b);</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-选择语句"><a href="#五-选择语句" class="headerlink" title="五.选择语句"></a>五.选择语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifelse</span>&#123;                            <span class="comment">//文件名字要与类名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//if:</span></span><br><span class="line">    <span class="keyword">if</span>()                     <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    &#123;&#125;                 </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;&#125;                       <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">     <span class="comment">//switch:</span></span><br><span class="line">     <span class="keyword">switch</span>(<span class="number">5</span>)&#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六-循环语句"><a href="#六-循环语句" class="headerlink" title="六.循环语句"></a>六.循环语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifelse</span>&#123;                          </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//while:</span></span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(++val&lt;=<span class="number">10</span>)           <span class="comment">//循环十次</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums+=val;             <span class="comment">// nums = nums + val;</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span>;             <span class="comment">//break 跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span>;         <span class="comment">//continue 结束本次循环,开始下次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;val)</span><br><span class="line">        nums+=val;            <span class="comment">//循环一直进行直达遇到 文件结束符或者错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val= <span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">        nums+=val;</span><br><span class="line">    <span class="comment">//do...while:</span></span><br><span class="line">    <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>()               <span class="comment">//至少进行一次循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七-数组"><a href="#七-数组" class="headerlink" title="七.数组"></a>七.数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">array</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> [] array1=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">100</span>];           <span class="comment">//动态初始化存一百个int 的数组</span></span><br><span class="line">        <span class="type">int</span> [] array2=<span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;    <span class="comment">//静态初始化</span></span><br><span class="line">        <span class="type">int</span> [] array3=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;               <span class="comment">//静态初始化省略</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">let</span> <span class="operator">=</span>array.length;                 <span class="comment">//数组长度</span></span><br><span class="line">        classname [] array=<span class="keyword">new</span> <span class="title class_">classname</span>[<span class="number">3</span>];   <span class="comment">//对象数组</span></span><br><span class="line">        <span class="type">classname</span> <span class="variable">one</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">classname</span>();</span><br><span class="line">        array[<span class="number">0</span>]=one;                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八-动态数组"><a href="#八-动态数组" class="headerlink" title="八.动态数组"></a>八.动态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	ArrayList&lt;string&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();       <span class="comment">//构造动态数组</span></span><br><span class="line">    list.add(<span class="string">&quot;三天后&quot;</span>);                               <span class="comment">//从最后面插入元素</span></span><br><span class="line">        基本类型      包装类</span><br><span class="line">          <span class="type">byte</span>     Byte</span><br><span class="line">          <span class="type">short</span>    Short</span><br><span class="line">          <span class="type">int</span>       Integer</span><br><span class="line">          <span class="type">long</span>      Long</span><br><span class="line">          <span class="type">float</span>     Float</span><br><span class="line">          <span class="type">double</span>    Double</span><br><span class="line">          <span class="type">char</span>       Character</span><br><span class="line">          <span class="type">boolean</span>    Boolean </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九-字符串"><a href="#九-字符串" class="headerlink" title="九.字符串"></a>九.字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">string</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1.字符串不可变</span></span><br><span class="line"><span class="comment">     2.字符串可共享</span></span><br><span class="line"><span class="comment">     3.字符串表现为char []数组,但实际上底层原理是byte[] 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     构造方法</span></span><br><span class="line"><span class="comment">     1.public String()                        //构造空字符串</span></span><br><span class="line"><span class="comment">     2.public String(char [] array)           //使用字符数组创建,地址指向字符数组再指向byte[]</span></span><br><span class="line"><span class="comment">     3.public String(byte [] array)</span></span><br><span class="line"><span class="comment">     4.string char=&quot;afhjg&quot;                    //地址指向字符串常量池,再指向字符数组再指向byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     使用方法</span></span><br><span class="line"><span class="comment">     1.public boolean equals(object obj)      //比较</span></span><br><span class="line"><span class="comment">     2.public int Length()                    //获取长度</span></span><br><span class="line"><span class="comment">     3.public String concat(String str)       //拼接字符串</span></span><br><span class="line"><span class="comment">     4.public char charAt(int index)          //获取指定位置字符串</span></span><br><span class="line"><span class="comment">     5.public int indexOf(String str)         //查找子串出现位置</span></span><br><span class="line"><span class="comment">     6.public String substring(int index)     //从参数位置开始截取到尾部</span></span><br><span class="line"><span class="comment">     7.public String substring(int begin,int end)//截取范围内字符串,前闭后开</span></span><br><span class="line"><span class="comment">     8.public char[] toCharArray()             //转换成Char数组</span></span><br><span class="line"><span class="comment">     9.public byte getBytes()                  //获取底层byte数组</span></span><br><span class="line"><span class="comment">     10.public String replace(CharSequencr oldString,CharSequencr NewString)//替换</span></span><br><span class="line"><span class="comment">     11.public String[] split(String reget)    //按指定参数分割字符串       &quot;,&quot; &quot; &quot;  //.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十-类和对象"><a href="#十-类和对象" class="headerlink" title="十.类和对象"></a>十.类和对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line">	<span class="comment">/*封装性 继承性 多态性*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1.所有成员变量都要用private</span></span><br><span class="line"><span class="comment">      2.成员变量的set和get函数</span></span><br><span class="line"><span class="comment">      3.无参构造函数            不写会赠送</span></span><br><span class="line"><span class="comment">      4.全参构造函数*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>&#123;                        <span class="comment">//定义类 </span></span><br><span class="line">    String name;                             <span class="comment">//属性定义在方法外面</span></span><br><span class="line">    <span class="type">int</span> age=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rage;                        <span class="comment">// 类外无法直接访问 通过定义方法间接访问</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> classroom;                    <span class="comment">//静态类型</span></span><br><span class="line">    <span class="built_in">this</span>.name;                               <span class="comment">//指类内的属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;                      <span class="comment">//方法不加static</span></span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat1</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;eat1&quot;</span>);         <span class="comment">//静态方法可以通过  student.eat1直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span>&#123;&#125;                      <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;    <span class="comment">//有参构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;System.out.println(<span class="string">&quot;第一次构造&quot;</span>);&#125; <span class="comment">//静态代码块在第一次构造时唯一使用一次</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。</span></span><br><span class="line"><span class="comment">例如：身体和心脏的关系。又如：汽车和发动机的关系。</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">1.成员内部类</span></span><br><span class="line"><span class="comment">2.局部内部类（包含匿名内部类）</span></span><br><span class="line"><span class="comment">成员内部类的定义格式：</span></span><br><span class="line"><span class="comment">修饰符class外部类名称f</span></span><br><span class="line"><span class="comment">修饰符class内部类名称f</span></span><br><span class="line"><span class="comment">注意：内用外，随意访问；外用内，需要内部类对象。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*继承特点: 单一继承性 多级继承性 多子类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">senerstudent</span> extend studend&#123;   <span class="comment">//定义子类继承父类</span></span><br><span class="line">    <span class="type">int</span> age=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">40</span>;</span><br><span class="line">    		System.out.println(age);       <span class="comment">//方法中的40</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.age);  <span class="comment">//类中的30</span></span><br><span class="line">            System.out.println(<span class="built_in">super</span>.age); <span class="comment">//父类的20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">senerstudent</span><span class="params">()</span>&#123;                 <span class="comment">//子类无参构造</span></span><br><span class="line">        <span class="built_in">super</span>();                           <span class="comment">//调用父类有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">senerstudent</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">50</span>)                   <span class="comment">//调用父类有参构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*方法覆盖重写的注意事项</span></span><br><span class="line"><span class="comment">		1.必须保证父子类之间方法的名称相同，参数列表也相同</span></span><br><span class="line"><span class="comment">		@override：写在方法前面，用来检测是不是有效的正确覆盖重写</span></span><br><span class="line"><span class="comment">		这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</span></span><br><span class="line"><span class="comment">		2.子类方法的返回值必须【小于等于】父类方法的返回值范围。</span></span><br><span class="line"><span class="comment">		小扩展提示：java.lang.object类是所有类的公共最高父类（祖宗类），java.lang.string就是object的子类</span></span><br><span class="line"><span class="comment">		3.子类方法的权限必须【大于等于】类方法的权限修饰符。</span></span><br><span class="line"><span class="comment">		小扩展提示：public&gt;protected&gt;（default）&gt;private</span></span><br><span class="line"><span class="comment">		备注：（default）不是关键字default，而是什么都不写，留空。*/</span></span><br><span class="line">    <span class="comment">/*继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment">	1.子类构造方法当中有一个默认隐含的“super（）调用，所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">	2.子类构造可以通过super关键字来调用父类重载构造。</span></span><br><span class="line"><span class="comment">	3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">	总结：</span></span><br><span class="line"><span class="comment">	子类必须调用父类构造方法，不写则赠送super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多态性*/</span></span><br><span class="line"><span class="comment">/*代码当中体现多态性，其实就是一句话：父类引用指向子类对象。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">父类概称对象名=new子类名称（）；</span></span><br><span class="line"><span class="comment">或者：</span></span><br><span class="line"><span class="comment">接口名称</span></span><br><span class="line"><span class="comment">对象名=new实现类名称（）；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*在多态的代码当中，成员方法的访问规则是：</span></span><br><span class="line"><span class="comment">看new的是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看右边。</span></span><br><span class="line"><span class="comment">对比一下：</span></span><br><span class="line"><span class="comment">成员变量：</span></span><br><span class="line"><span class="comment">编译看左边，运行还看左边。</span></span><br><span class="line"><span class="comment">成员方法：编译看左边，运行看右边。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String【】args)</span>&#123;</span><br><span class="line"><span class="comment">//使用多态的写法</span></span><br><span class="line"><span class="comment">//左侧父类的引用，指向了右侧子类的对象</span></span><br><span class="line">Fu obj= <span class="keyword">new</span> <span class="title class_">zi</span>（）;                     <span class="comment">//多态性</span></span><br><span class="line">obj.method（）;                         <span class="comment">//zi fu 都有 用子</span></span><br><span class="line">obj.methodFu（）;                       <span class="comment">//子无用父</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果不用多态，只用子类，那么写法是：</span></span><br><span class="line"><span class="comment">Teacher one new Teacher();</span></span><br><span class="line"><span class="comment">one.work():/∥讲课</span></span><br><span class="line"><span class="comment">Assistant two new Assistant();</span></span><br><span class="line"><span class="comment">two.work():/∥辅导</span></span><br><span class="line"><span class="comment">我现在唯一要做的事情，就是调用work方法，其他的功能不关心。</span></span><br><span class="line"><span class="comment">如果使用多态的写法，对比一下：</span></span><br><span class="line"><span class="comment">Employee one new TeacherO;</span></span><br><span class="line"><span class="comment">one,work():/∥讲课</span></span><br><span class="line"><span class="comment">Employee two new AssistantO;</span></span><br><span class="line"><span class="comment">two.work();/∥辅导</span></span><br><span class="line"><span class="comment">好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类</span></span><br><span class="line"><span class="keyword">import</span> 路径.student                         <span class="comment">//导入包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">std</span>&#123;                           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">student</span> <span class="variable">std</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();       <span class="comment">//使用无参构造函数定义对象</span></span><br><span class="line">        std.name=<span class="string">&quot;阿凡达&quot;</span>;                  <span class="comment">//定义对象属性</span></span><br><span class="line">        std.age=<span class="number">100</span>;</span><br><span class="line">        std.eat();                         <span class="comment">//使用对象方法</span></span><br><span class="line">        student std1= <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;阿发说&quot;</span>,<span class="number">12</span>);<span class="comment">//使用全参构造函数定义对象</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十一-抽象类和抽象方法"><a href="#十一-抽象类和抽象方法" class="headerlink" title="十一.抽象类和抽象方法"></a>十一.抽象类和抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class,之前写上abstract即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> eat（）;</span><br><span class="line"><span class="comment">//这是普通的成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> normalMethod（）&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1.不能直接创建new抽象类对象</span></span><br><span class="line"><span class="comment">2.必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3.子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4.创建子类对象进行使用。|*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> eat（）</span><br><span class="line">System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十二-转型"><a href="#十二-转型" class="headerlink" title="十二.转型"></a>十二.转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对象的向上转型，其实就是多态写法：</span><br><span class="line">格式：父类名称对象名=<span class="keyword">new</span>子类名称():</span><br><span class="line">Animal animal <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">含义：右侧创建一个子类对象，把它当做父类来看待使用。</span><br><span class="line">创建了一只猫，当做动物看待，没问题。</span><br><span class="line">注意事项：向上转型一定是安全的。从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。</span><br><span class="line">    </span><br><span class="line">向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：</span><br><span class="line">对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。</span><br><span class="line">解决方案：用对象的向下转型[还原]</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对象的向下转型，其实是一个【还原】的动作。</span><br><span class="line">格式：子类名称对象名=（子类名称父类对象：</span><br><span class="line">含义：将父类对象，</span><br><span class="line">【还原】成为本来的子类对象。</span><br><span class="line">Animal animal=<span class="keyword">new</span> <span class="title class_">Cat</span>():/本来是猫，向上转型成为动物</span><br><span class="line">Catcat=(Cat)animal;;/∥本来是猫，已经被当做动物了，还原回来成为本来的猫</span><br><span class="line">注意事项：</span><br><span class="line">.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。</span><br><span class="line">b.如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错。ClassCastException</span><br><span class="line">    </span><br><span class="line">如何才能知道一个父类引用的对象，本来是什么子类？</span><br><span class="line">格式：</span><br><span class="line">对象<span class="keyword">instanceof</span>类名称</span><br><span class="line">这将会得到一个<span class="type">boolean</span>值结果，也就是判断前面的对象能不能当做后面类型的实例。</span><br></pre></td></tr></table></figure>



<h3 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口就是多个类的公共规范。</span></span><br><span class="line"><span class="comment">接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</span></span><br><span class="line"><span class="comment">如何定义一个接口的格式：</span></span><br><span class="line"><span class="comment">public interface接口名称&#123;</span></span><br><span class="line"><span class="comment">//接口内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">备注：换成了关键字interface.之后，编译生成的字节码文件仍然是：。java--&gt;.class.</span></span><br><span class="line"><span class="comment">如果是Java7,那么接口中可以包含的内容有：</span></span><br><span class="line"><span class="comment">1.常量</span></span><br><span class="line"><span class="comment">2.抽象方法</span></span><br><span class="line"><span class="comment">如果是Java8,还可以额外包含有：</span></span><br><span class="line"><span class="comment">3.默认方法</span></span><br><span class="line"><span class="comment">4.静态方法</span></span><br><span class="line"><span class="comment">果是JavaT9,还可以额外包含有：</span></span><br><span class="line"><span class="comment">5.私有方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*接口使用步骤：</span></span><br><span class="line"><span class="comment">1.接口不能直接使用，必须有一个实现类来实现该接口。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口名称()</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。</span></span><br><span class="line"><span class="comment">实现：去掉abstract关键字，加上方法体大括号。</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">创建实现类的对象，进行使用。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.接口的默认方法，可以通过接口实现类对象，直接调用</span></span><br><span class="line"><span class="comment">2.接口的默认方法，也可以被接口实现类进行覆盖重写。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。</span></span><br><span class="line"><span class="comment">正确用法：通过接口名称，直接调用其中的静态方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">接口名称。静态方法名（参数）；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用接口的时候，需要注意：</span></span><br><span class="line"><span class="comment">1.接口是没有静态代码块或者构造方法的。</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</span></span><br><span class="line"><span class="comment">格式</span></span><br><span class="line"><span class="comment">public cLass MyInterfaceImpl implements MyInterfaceA,MyInterfaceB</span></span><br><span class="line"><span class="comment">//覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</span></span><br><span class="line"><span class="comment">5.</span></span><br><span class="line"><span class="comment">如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</span></span><br><span class="line"><span class="comment">6.</span></span><br><span class="line"><span class="comment">一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.类与类之间是单继承的。直接父类只有一个。</span></span><br><span class="line"><span class="comment">2.类与接口之间是多实现的。一个类可以实现多个接口。</span></span><br><span class="line"><span class="comment">3.接口与接口之间是多继承的。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.多个父接口当中的抽象方法如果重复，梁关系。</span></span><br><span class="line"><span class="comment">2.多个父接口当中的默认方法如果重复，邪么子接口必须进行默认方法的覆盖重写，[而且带着defaulti关键字]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">usb</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在任何版本的Java中，接口都能定义抽象方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public abstract返回值类型方法名称（参数列表）；</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></span><br><span class="line"><span class="comment">2.这两个关键字修饰符，可以选择性地省略。(今天刚学，所以不推荐。)</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">方法的三要素，可以随意定义。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;          <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;                   <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;                 <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;                          <span class="comment">//抽象方法</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">/*从Java8开始，接口里允许定义默认方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public default返回值类型方法名称（参数列表）&#123;方法体&#125;</span></span><br><span class="line"><span class="comment">备注：接口当中的默认方法，可以解决接口升级的问题。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span>&#123;&#125;          <span class="comment">//默认方法        调用默认方法如果当前类中没有就会向上找</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*从]ava8开始，接口当中允许定义静态方法</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static返回值类型方法名称（参数列表）&#123;&#125;</span></span><br><span class="line"><span class="comment">方法体</span></span><br><span class="line"><span class="comment">提示：就是将abstract或者default换成static即可，带上方法体。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m6</span><span class="params">()</span>&#123;&#125;           <span class="comment">//静态方法         不能通过类的对象调用只能通过接口名称直接调用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*问题描述：</span></span><br><span class="line"><span class="comment">我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。</span></span><br><span class="line"><span class="comment">但是这个共有方法不应该让实现类使用，应该是私有化的。</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">从Java9开始，接口当中允许定义私有方法。</span></span><br><span class="line"><span class="comment">1.普通私有方法，解决多个默认方法之间重复代码问题</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">方法体&#125;</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">静态私有方法，解决多个静态方法之闸重复代码问题</span></span><br><span class="line"><span class="comment">棉式：</span></span><br><span class="line"><span class="comment">private static返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">方法体&#125;*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。</span></span><br><span class="line"><span class="comment">从效果上看，这其实就是接口的【常量】。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final数据类型常量名称=数据值；</span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">旦使用final关键字进行修饰，说明不可改变。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">接口当中的常量，可以省略public static final,注意：不写也照样是这样。</span></span><br><span class="line"><span class="comment">2.接口当中的常量，必须进行赋值；不能不赋值。</span></span><br><span class="line"><span class="comment">3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//这其实就是一个常量，一旦赋值，不可以修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> NUM_OF_MYCLASS <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十四-this和super专题"><a href="#十四-this和super专题" class="headerlink" title="十四.this和super专题"></a>十四.this和super专题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*super关键字的用法有三种：</span></span><br><span class="line"><span class="comment">1.在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3.在子类的构造方法中，访问父类的构造方法。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*supe关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</span></span><br><span class="line"><span class="comment">1.在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2.在本类的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3.在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种用法当中要注意：</span></span><br><span class="line"><span class="comment">4.this(..·)调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">3.superi和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十五-final专题"><a href="#十五-final专题" class="headerlink" title="十五.final专题"></a>十五.final专题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*finali关键字代表最终、不可改变的。</span></span><br><span class="line"><span class="comment">常见四种用法：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">可以用来修饰一个类</span></span><br><span class="line"><span class="comment">2.可以用来修饰一个方法</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">还可以用来修饰一个局部变量</span></span><br><span class="line"><span class="comment">4.</span></span><br><span class="line"><span class="comment">还可以用来修饰一个成员变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*当final关键字用来修饰一个类的时候，格式：</span></span><br><span class="line"><span class="comment">public final class类名称f</span></span><br><span class="line"><span class="comment">.</span></span><br><span class="line"><span class="comment">含义：当前这个类不能有任何的子类。（太监类）</span></span><br><span class="line"><span class="comment">注意：一个类如果是fina(的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当fial关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符final</span></span><br><span class="line"><span class="comment">返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">/方法体</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">对于类、方法来说，abstracti关键字和final:关键字不能同时使用，因为矛盾。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于局部变量来说</span></span><br><span class="line"><span class="comment">如果类型是基本类型那么不可变的是类型的值</span></span><br><span class="line"><span class="comment">如果类型是引用类型那么不可变的是类型的地址*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。</span></span><br><span class="line"><span class="comment">1.由于成员变量具有默认值，所以用了final.之后必须手动赋值，不会再给默认值了。</span></span><br><span class="line"><span class="comment">2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">必须保证类当中所有重载的构造方法，都最终会对fna的成员变量进行赋值。*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十六-public-protect-default-private-static-final-abstract"><a href="#十六-public-protect-default-private-static-final-abstract" class="headerlink" title="十六.public protect  default private static final abstract"></a>十六.public protect  default private static final abstract</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、修饰方法的修饰符</span><br><span class="line"><span class="keyword">public</span>:被该修饰符修饰的方法可以被任何类通过对象.方法使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:被该修饰符修饰的方法可以被该类自身、本包中的类、和子类（是子类而非父类）所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:被该修饰符修饰的方法只能被该类使用</span><br><span class="line"></span><br><span class="line">缺省：被该修饰符修饰的方法只能被该类、本包中的类所使用（缺省的意思就是不用写）</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>：被<span class="keyword">static</span>修饰的方法是一个静态方法，可以被类直接使用，可以通过类名.方法名直接调用,<span class="keyword">static</span>可以和<span class="keyword">final</span>一起使用(在类中修饰的<span class="keyword">static</span>方法可以被对象和类名调用,但是在接口中定义的<span class="keyword">static</span>方法只能通过接口名调用)</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span>：被<span class="keyword">abstract</span>修饰的方法，不能写方法体，且该类必须是抽象类,抽象类中可以没有抽象方法，但是有抽象方法的类必须是一个抽象类</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>：被该修饰符修饰的方法不能被重写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、修饰类的修饰符</span><br><span class="line"><span class="keyword">public</span>：被<span class="keyword">public</span>修饰的类可以被任何类所使用（本包、其他包、自身）</span><br><span class="line"></span><br><span class="line">缺省：缺省的意思就是不写权限访问控制符，被此修饰符修饰的类只能被该类自身，本包中的类所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span>：被此修饰符修饰的类是一个抽象类，抽象类是不能被实例化的，(抽象类主要是用来被继承的)，<span class="keyword">abstract</span>不能和<span class="keyword">final</span>同时修饰一个类</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>：用<span class="keyword">final</span>修饰的类表示最终类，该类不能被继承，且该类也不能是一个抽象类</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、修饰成员变量的修饰符</span><br><span class="line"><span class="keyword">public</span>:被该修饰符修饰的成员变量可以被任何类使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:被该修饰符修饰的成员变量能被该类自身、本包中的类、和子类（是子类而非父类）所使用，即用<span class="keyword">protected</span>修饰的属性在其他包中的子类中可以通过子类对象进行访问，不能通过本类对象进行访问</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:被该修饰符修饰的成员变量只能被该类使用</span><br><span class="line"></span><br><span class="line">缺省：被该修饰符修饰的成员变量只能被该类、本包中的类所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>：被<span class="keyword">static</span>修饰的成员变量可以被类直接使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>:被该修饰符修饰的成员变量是常量</span><br></pre></td></tr></table></figure>

<h3 id="十七-常用api"><a href="#十七-常用api" class="headerlink" title="十七.常用api"></a>十七.常用api</h3><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类。</span></span><br><span class="line"><span class="comment">Object作为所有类的父类，提供了很多常用的方法给每个子类对象拿来使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(object o)</span>      <span class="comment">// 默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址</span></span><br><span class="line">      <span class="comment">//父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息！！ </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equal</span><span class="params">(object o)</span>      <span class="comment">//默认是比较当前对象与另一个对象的地址是否相同，相同返回true,不同返回false</span></span><br><span class="line">      <span class="comment">//为了被子类重写，以便子类自己来定制比较规则（比如比较对象内容）。</span></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="objects类"><a href="#objects类" class="headerlink" title="objects类"></a>objects类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Objects是一个工具类，提供了一些方法去完成一些功能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span>     <span class="comment">//比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Object obj)</span>            <span class="comment">//判断变量是否为null ,为null返回true ,反之</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*StringBuilder概述</span></span><br><span class="line"><span class="comment">StringBuilder是一个可变的字符串的操作类，我们可以把它看成是一个对象容器。</span></span><br><span class="line"><span class="comment">使用StringBuilder的核心作用：操作字符串的性能比String要更高（如拼接、修改等）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span>                          <span class="comment">//创建一个空白的可变的字符串对象，不包含任何内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span>                <span class="comment">//创建一个指定字符串内容的可变字符串对象</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(任意类型)</span>         <span class="comment">//添加数据并返回StringBuilder对象本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">reverse</span><span class="params">()</span>                     <span class="comment">//将对象的内容反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>                               <span class="comment">//返回对象内容长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>                       <span class="comment">//通过toString()就可以实现把StringBuilder转换为String</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Date-类概述"><a href="#Date-类概述" class="headerlink" title="Date 类概述"></a><strong>Date</strong> <strong>类概述</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Date类代表当前所在系统的日期时间信息。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>          <span class="comment">//创建一个Date对象，代表的是系统当前此刻日期时间。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>    <span class="comment">//把时间毫秒值转换成Date日期对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span><span class="comment">//返回从1970年1月1日    00:00:00走到此刻的总的毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>  <span class="comment">//设置日期对象的时间为当前时间毫秒值对应的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a><strong>SimpleDateFormat</strong>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*代表简单日期格式化，可以用来把日期时间格式化成为我们想要的形式。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> SimpleDateFormat​(String pattern) <span class="comment">//创建简单日期格式化对象，并封装格式化的形式信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span><span class="comment">//将日期格式化成日期/时间字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Object time)</span><span class="comment">//将时间毫秒值式化成日期/时间字符串</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span> <span class="comment">//  从给定字符串的开始解析文本以生成日期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Calendar代表了系统此刻日期对应的日历对象。</span></span><br><span class="line"><span class="comment">Calendar是一个抽象类，不能直接创建对象。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span><span class="comment">//获取当前日历对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>  <span class="comment">//取日期中的某个字段信息。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field,<span class="type">int</span> value)</span><span class="comment">//修改日历的某个字段信息。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field,<span class="type">int</span> amount)</span><span class="comment">//为某个字段增加/减少指定的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span><span class="comment">//拿到此刻日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span><span class="comment">//拿到此刻时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：calendar是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。*/</span></span><br></pre></td></tr></table></figure>

<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/* 基本类型      包装类</span></span><br><span class="line"><span class="comment">          byte     Byte</span></span><br><span class="line"><span class="comment">          short    Short</span></span><br><span class="line"><span class="comment">          int       Integer</span></span><br><span class="line"><span class="comment">          long      Long</span></span><br><span class="line"><span class="comment">          float     Float</span></span><br><span class="line"><span class="comment">          double    Double</span></span><br><span class="line"><span class="comment">          char       Character</span></span><br><span class="line"><span class="comment">          boolean    Boolean */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实就是8种基本数据类型对应的引用类型。</span></span><br><span class="line"><span class="comment">Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。</span></span><br><span class="line"><span class="comment">后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自动装箱：基本类型的数据和变量可以直接赋值给包装类型的变量。</span></span><br><span class="line"><span class="comment">自动拆箱：包装类型的变量可以直接赋值给基本数据类型的变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">包装类的特有功能</span></span><br><span class="line"><span class="comment">包装类的变量的默认值可以是null，容错率更高。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以把基本类型的数据转换成字符串类型(用处不大)</span></span><br><span class="line"><span class="comment">调用toString()方法得到字符串结果。</span></span><br><span class="line"><span class="comment">调用Integer.toString(基本类型的数据)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以把字符串类型的数值转换成真实的数据类型（真的很有用）</span></span><br><span class="line"><span class="comment">Integer.parseInt(“字符串类型的整数”)</span></span><br><span class="line"><span class="comment">Double.parseDouble(“字符串类型的小数”)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串对象提供了匹配正则表达式的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> matches​(String regex)        <span class="comment">//判断是否匹配正则表达式，匹配返回true，不匹配返回false。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符类(默认匹配一个字符)</span></span><br><span class="line"><span class="comment">[abc]	       只能是a, b, 或c</span></span><br><span class="line"><span class="comment">[^abc]	       除了a, b, c之外的任何字符</span></span><br><span class="line"><span class="comment">[a-zA-Z]               a到z A到Z，包括（范围）</span></span><br><span class="line"><span class="comment">[a-d[m-p]]	       a到d，或m通过p：（[a-dm-p]联合）</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[def]]	       d, e, 或f(交集)</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[^bc]]	       a到z，除了b和c：（[ad-z]减法）</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[^m-p]]     a到z，除了m到p：（[a-lq-z]减法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">预定义的字符类(默认匹配一个字符)</span></span><br><span class="line"><span class="comment">.	任何字符</span></span><br><span class="line"><span class="comment">\d	一个数字： [0-9]</span></span><br><span class="line"><span class="comment">\D	非数字： [^0-9]</span></span><br><span class="line"><span class="comment">\s	一个空白字符： [ \t\n\x0B\f\r]</span></span><br><span class="line"><span class="comment">\S	非空白字符： [^\s]</span></span><br><span class="line"><span class="comment">\w	[a-zA-Z_0-9] 英文、数字、下划线</span></span><br><span class="line"><span class="comment">\W	 [^\w] 一个非单词字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">贪婪的量词（配合匹配多个字符）</span></span><br><span class="line"><span class="comment">X?	X , 一次或根本不</span></span><br><span class="line"><span class="comment">X*	X，零次或多次</span></span><br><span class="line"><span class="comment">X+	X , 一次或多次</span></span><br><span class="line"><span class="comment">X &#123;n&#125;	X，正好n次</span></span><br><span class="line"><span class="comment">X &#123;n, &#125;	X，至少n次</span></span><br><span class="line"><span class="comment">X &#123;n,m&#125;	X，至少n但不超过m次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组操作工具类，专门用于操作数组元素的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(类型[] a)</span>             <span class="comment">//返回数组的内容（字符串形式）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(类型[] a)</span>                   <span class="comment">//对数组进行默认升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(类型[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>    <span class="comment">//使用比较器对象自定义排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span>            <span class="comment">//二分搜索数组中的数据，存在返回索引，不存在返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="十八-集合"><a href="#十八-集合" class="headerlink" title="十八.集合"></a>十八.集合</h3><p>集合分为Collection单列和Map双列集合</p>
<p>Collection接口有两个继承接口,List和Set</p>
<p>List接口有两个实现类,**ArrayList、LinekdList **</p>
<p>Set接口有两个实现类,<strong>HashSet.TreeSet</strong>,HashSet有个继承类为LinkedHashSet</p>
<p>Collection集合特点:</p>
<p><strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。</p>
<p>ArrayList、LinekdList ：有序、可重复、有索引。</p>
<p><strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。</p>
<p>HashSet: 无序、不重复、无索引；LinkedHashSet: <strong>有序</strong>、不重复、无索引。</p>
<p>TreeSet：<strong>按照大小默认升序排序、</strong>不重复、无索引。</p>
<p><strong>注意：集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p>
<h4 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h4><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p>
<p><strong>Collection API如下:</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  boolean add(E e)</td>
<td>把给定的对象添加到当前集合中</td>
</tr>
<tr>
<td>public  void clear()</td>
<td>清空集合中所有的元素</td>
</tr>
<tr>
<td>public  boolean remove(E e)</td>
<td>把给定的对象在当前集合中删除</td>
</tr>
<tr>
<td>public  boolean contains(Object obj)</td>
<td>判断当前集合中是否包含给定的对象</td>
</tr>
<tr>
<td>public  boolean isEmpty()</td>
<td>判断当前集合是否为空</td>
</tr>
<tr>
<td>public  int size()</td>
<td>返回集合中元素的个数。</td>
</tr>
<tr>
<td>public  Object[] toArray()</td>
<td>把集合中的元素，存储到数组中</td>
</tr>
</tbody></table>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="方式一：迭代器"><a href="#方式一：迭代器" class="headerlink" title="方式一：迭代器"></a>方式一：迭代器</h5><p>迭代器在Java中的代表是<strong>Iterator</strong>，迭代器是集合的专用的遍历方式。</p>
<p><strong>Collection****集合获取迭代器</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Iterator<E></E></strong>  <strong>iterator()</strong></td>
<td>返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td>
</tr>
</tbody></table>
<p><strong>Iterator****中的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>询问当前位置是否有元素存在，存在返回true ,不存在返回false</td>
</tr>
<tr>
<td>E  next()</td>
<td>获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="方式二：foreach-增强for循环"><a href="#方式二：foreach-增强for循环" class="headerlink" title="方式二：foreach/增强for循环"></a>方式二：foreach/增强for循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(元素数据类型 变量名 : 数组或者Collection集合) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //在此处使用变量即可，该变量就是元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">既可以遍历集合也可以遍历数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String ele : list) &#123;</span><br><span class="line">        System.out.println(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="方式三：lambda表达式"><a href="#方式三：lambda表达式" class="headerlink" title="方式三：lambda表达式"></a>方式三：lambda表达式</h5><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p><strong>List系列集合特点</strong></p>
<p> ArrayList、LinekdList ：有序，可重复，有索引。</p>
<p>有序：存储和取出的元素顺序一致</p>
<p>有索引：可以通过索引操作元素</p>
<p>可重复：存储的元素可以重复</p>
<p><strong>List</strong> <strong>集合特有方法</strong></p>
<p>List集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int  index,E element)</td>
<td>在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td>E remove(int  index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>E set(int index,E  element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E get(int  index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>ArrayList</strong> <strong>集合底层原理</strong></p>
<p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。</p>
<p>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。</p>
<p>当长度超过当前数组长时,创建一个更大的数组,并对老数组进行迁移</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>LinkedList</strong> <strong>的特点</strong></p>
<p>l底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</p>
<p><strong>LinkedList</strong> <strong>集合的特有功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void addFirst(E e)</td>
<td>在该列表开头插入指定的元素</td>
</tr>
<tr>
<td>public  void addLast(E e)</td>
<td>将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td>public  E getFirst()</td>
<td>返回此列表中的第一个元素</td>
</tr>
<tr>
<td>public  E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>public  E removeFirst()</td>
<td>从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td>public  E removeLast()</td>
<td>从此列表中删除并返回最后一个元素</td>
</tr>
</tbody></table>
<p>当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。</p>
<p>删除当前元素,指针后移会导致跳过删除元素后一个元素.</p>
<p>迭代器遍历集合且直接用集合删除元素的时候可能出现。</p>
<p>迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</p>
<p>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</p>
<p>使用for循环遍历并删除元素不会存在这个问题。</p>
<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</p>
<p>泛型的格式：&lt;数据类型&gt;; 注意：泛型只能支持引用数据类型。</p>
<p>集合体系的全部接口和实现类都是支持泛型的使用的。</p>
<p><strong>泛型的好处：</strong></p>
<p>统一数据类型。</p>
<p>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</p>
<p>泛型有:泛型类,泛型方法,泛型接口</p>
<p>泛型类</p>
<p>定义类时同时定义了泛型的类就是泛型类。</p>
<p>泛型类的格式：修饰符 class 类名&lt;泛型变量&gt;{ }</p>
<p>泛型方法</p>
<p>定义方法时同时定义了泛型的方法就是泛型方法。</p>
<p>泛型方法的格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</p>
<p>泛型接口</p>
<p>使用了泛型定义的接口就是泛型接口。</p>
<p>泛型接口的格式：修饰符 interface 接口名称&lt;泛型变量&gt;{}</p>
<p>? 可以在“使用泛型”的时候代表一切类型。</p>
<p> E T K V 是在定义泛型的时候使用的。</p>
<p>通配符上下限:</p>
<p>? <strong>extends</strong> <strong>Car</strong>: ?必须是Car或者其子类  泛型上限</p>
<p> ? <strong>super</strong> <strong>Car</strong> ： ?必须是Car或者其父类  泛型下限</p>
<h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p><strong>Set</strong> <strong>系列集合特点</strong></p>
<p>无序：存取顺序不一致</p>
<p>不重复：可以去除重复</p>
<p>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素。</p>
<p><strong>Set</strong> <strong>集合</strong> <strong>实现类特点</strong></p>
<p> HashSet : 无序、不重复、无索引。</p>
<p>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</p>
<p>TreeSet：<strong>排序</strong>、不重复、无索引。</p>
<p><strong>Set</strong> <strong>集合的功能上基本上与</strong> <strong>Collection</strong> <strong>的</strong> <strong>API</strong> <strong>一致。</strong></p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h5><p><strong>HashSet</strong> <strong>底层原理</strong></p>
<p>HashSet集合底层采取<strong>哈希表</strong>存储的数据。</p>
<p>哈希表是一种对于增删改查数据性能都较好的结构。</p>
<p><strong>哈希表的组成</strong></p>
<p>JDK8之前的，底层使用<strong>数组</strong> <strong>+</strong> <strong>链表</strong>组成</p>
<p>JDK8开始后，底层采用<strong>数组</strong> <strong>+</strong> <strong>链表</strong> <strong>+</strong> <strong>红黑树</strong>组成。</p>
<p>在了解哈希表之前需要先理解哈希值的概念:是JDK根据对象的<strong>地址</strong> <strong>，</strong>按照某种规则算出来的int类型的<strong>数值。</strong></p>
<p><strong>Object</strong> <strong>类的</strong> <strong>API</strong></p>
<p>public int hashCode()：返回对象的哈希值</p>
<p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p>
<p>默认情况下，不同对象的哈希值是不同的。</p>
<p><strong>HashSet1.7</strong> <strong>版本原理解析：数组</strong> <strong>+</strong> <strong>链表</strong> <strong>+</strong> <strong>（结合哈希算法）</strong></p>
<p>①创建一个默认长度16的数组，数组名table</p>
<p>②根据元素的哈希值跟数组的长度求余计算出应存入的位置（哈希算法）</p>
<p>③判断当前位置是否为null，如果是null直接存入</p>
<p>④如果位置不为null，表示有元素，则调用equals方法比较</p>
<p>⑤如果一样，则不存，如果不一样，则存入数组，</p>
<p>JDK 7新元素占老元素位置，指向老元素</p>
<p>JDK 8中新元素挂在老元素下面</p>
<p><strong>JDK1.8</strong> <strong>版本开始</strong> <strong>HashSet</strong> <strong>原理解析</strong></p>
<p>底层结构：哈希表（数组、链表、红黑树的结合体）</p>
<p>当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过<strong>8</strong>的时候，自动转换为红黑树。</p>
<p><strong>HashSet</strong> <strong>去重复原理解析</strong></p>
<p> ①创建一个默认长度16的数组，数组名table</p>
<p>②根据元素的<strong>哈希值</strong>跟<strong>数组的长度求余</strong>计算出应存入的位置<strong>（哈希算法）</strong></p>
<p>③判断当前位置是否为null，如果是null直接存入</p>
<p>④<strong>如果位置不为</strong> <strong>null</strong> <strong>，表示有元素，则调用</strong> <strong>equals</strong> <strong>方法比较</strong></p>
<p>⑤<strong>如果一样，则不存，如果不一样，则存入数组，</strong></p>
<p><strong>结论：如果希望</strong> <strong>Set</strong> <strong>集合认为</strong> <strong>2</strong> <strong>个内容一样的对象是重复的，</strong></p>
<p><strong>必须重写对象的</strong> <strong>hashCode</strong> <strong>()</strong> <strong>和</strong> <strong>equals()</strong> <strong>方法</strong></p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p><strong>LinkedHashSet</strong> <strong>集合概述和特点</strong></p>
<p><strong>有序</strong>、不重复、无索引。</p>
<p>这里的有序指的是保证存储和取出的元素顺序一致</p>
<p><strong>原理</strong>：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p><strong>TreeSet</strong> <strong>集合概述和特点</strong></p>
<p>不重复、无索引、可排序</p>
<p>可排序：按照元素的大小默认升序（有小到大）排序。</p>
<p>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</p>
<p><strong>注意：</strong> <strong>TreeSet</strong> <strong>集合是一定要排序的，可以将元素按照指定的规则进行排序。</strong></p>
<p>对于数值类型：Integer , Double，官方默认按照大小进行升序排序。</p>
<p>对于字符串类型：默认按照首字符的编号升序排序。</p>
<p>对于自定义类型如Student对象，TreeSet无法直接排序。</p>
<p><strong>结论：想要使用</strong> <strong>TreeSet</strong> <strong>存储自定义类型，需要制定排序规则</strong></p>
<p><strong>自定义排序规则</strong></p>
<p>lTreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则</p>
<p><strong>方式一</strong></p>
<p>让自定义的类（如学生类）<strong>实现</strong> <strong>Comparable</strong> <strong>接口</strong>重写里面的<strong>compareTo</strong>方法<strong>来定制比较规则。</strong></p>
<p><strong>方式二</strong>(优先级高)</p>
<p><strong>TreeSet</strong> <strong>集合有参数构造器，可以设置</strong> <strong>Comparator</strong> <strong>接口对应的比较器对象，来定制比较规则。</strong></p>
<p><strong>两种方式中，关于返回值的规则：</strong></p>
<p>l如果认为第一个元素大于第二个元素返回正整数即可。</p>
<p>l如果认为第一个元素小于第二个元素返回负整数即可。</p>
<p>l如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素，认为两者重复。</p>
<p><strong>注意：如果</strong> <strong>TreeSet</strong> <strong>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</strong></p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据。</p>
<p>可变参数的格式：数据类型…参数名称</p>
<p>接收参数非常灵活，方便。可以不接收参数，可以接收1个或者多个参数，也可以接收一个数组</p>
<p><strong>可变参数在方法内部本质上就是一个数组。</strong></p>
<p>1.一个形参列表中可变参数只能有一个</p>
<p>2.可变参数必须放在形参列表的最后面</p>
<h4 id="Collections-集合工具类"><a href="#Collections-集合工具类" class="headerlink" title="Collections 集合工具类"></a><strong>Collections</strong> <strong>集合工具类</strong></h4><p>java.utils.Collections:是集合工具类</p>
<p>作用：Collections并不属于集合，是用来操作集合的工具类。</p>
<p><strong>Collections常用的API</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> boolean  addAll(Collection&lt;? super T&gt; c, T… elements)</T></td>
<td>给集合对象批量添加元素</td>
</tr>
<tr>
<td>public static void shuffle(List&lt;?&gt; list)</td>
<td>打乱List集合元素的顺序</td>
</tr>
</tbody></table>
<p><strong>Collections</strong> <strong>排序相关</strong> <strong>API</strong></p>
<p>使用范围：只能对于List集合的排序。</p>
<p><strong>排序方式</strong> <strong>1</strong> <strong>：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list)</T></T></td>
<td>将集合中元素按照默认规则排序</td>
</tr>
</tbody></table>
<p>注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</p>
<p><strong>排序方式</strong> <strong>2</strong> <strong>：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; c)</T></T></td>
<td>将集合中元素按照指定规则排序</td>
</tr>
</tbody></table>
<h4 id="MAP集合"><a href="#MAP集合" class="headerlink" title="MAP集合"></a>MAP集合</h4><p><strong>Map</strong> <strong>集合概述和使用</strong></p>
<p>Map集合是一种双列集合，每个元素包含两个数据。</p>
<p>Map集合的每个元素的格式：key=value(键值对元素)。</p>
<p>Map集合也被称为“<strong>键值对集合</strong>”。</p>
<p><strong>Map</strong> <strong>集合整体格式：</strong></p>
<p>Collection集合的格式: [元素1,元素2,元素3..]</p>
<p>Map集合的完整格式：{key1=value1 , key2=value2 , key3=value3 , …}</p>
<p><img src="/2022/09/18/JAVA/myblog\source_posts\Linux\Snipaste_2022-11-04_18-56-31.png"></p>
<p><strong>使用最多的</strong> <strong>Map</strong> <strong>集合是</strong> <strong>HashMap</strong> <strong>。</strong></p>
<p>重点掌握HashMap , LinkedHashMap , TreeMap。其他的后续理解。</p>
<p><strong>Map</strong> <strong>集合的键</strong> <strong>无序、不重复的</strong></p>
<p><strong>Map</strong> <strong>集合的值</strong> <strong>值不做要求</strong> <strong>可以重复</strong></p>
<p><strong>Map集合体系特点</strong></p>
<p>Map集合的特点都是由键决定的。</p>
<p>Map集合的键是无序,不重复的，无索引的，值不做要求（可以重复）。</p>
<p>Map集合后面重复的键对应的值会覆盖前面重复键的值。</p>
<p>Map集合的键值对都可以为null。</p>
<p><strong>Map集合实现类特点</strong></p>
<p>HashMap:元素按照键是无序，不重复，无索引，值不做要求。（与Map体系一致）</p>
<p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求。</p>
<p>TreeMap：元素按照建是<strong>排序</strong>，不重复，无索引的，值不做要求。</p>
<p><strong>Map集合</strong> </p>
<p>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map &lt;String,Integer&gt; maps =new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V  put(K key,V value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V  remove(Object key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>void  clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int  size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式有：3种。</strong></p>
<p>方式一：键找值的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</p>
<p>方式二：键值对的方式遍历，把“键值对“看成一个整体，难度较大。</p>
<p>方式三：JDK 1.8开始之后的新技术：Lambda表达式。</p>
<p><strong>Map集合的遍历方式一：键找值</strong></p>
<p>先获取Map集合的全部键的Set集合。</p>
<p>遍历键的Set集合，然后通过键提取对应值。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set<K>  keySet()</K></td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>V  get(Object key)</td>
<td>根据键获取值</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式二：键值对</strong></p>
<p>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</p>
<p>遍历Set集合，然后提取键以及提取值。</p>
<p><strong>键值对涉及到的API:</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td>K getKey()</td>
<td>获得键</td>
</tr>
<tr>
<td>V getValue()</td>
<td>获取值</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式三Lambda</strong></p>
<p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(BiConsumer&lt;?  super  K,  ? super  V&gt;  action)</td>
<td>结合lambda遍历Map集合</td>
</tr>
</tbody></table>
<p><img src="/2022/09/18/JAVA/myblog\source_posts\Linux\Snipaste_2022-11-04_19-17-39.png"></p>
<h5 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a><strong>HashMap的特点</strong></h5><p>HashMap是Map里面的一个实现类。特点都是由键决定的：无序、不重复、无索引</p>
<p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</p>
<p>HashMap跟HashSet底层原理是一模一样的，都是哈希表结构，只是HashMap的每个元素包含两个值而已。</p>
<p><strong>实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</strong></p>
<p><strong>1.HashMap的特点和底层原理</strong></p>
<p>由键决定：无序、不重复、无索引。HashMap底层是哈希表结构的。</p>
<p>依赖hashCode方法和equals方法保证<strong>键</strong>的唯一。</p>
<p>如果<strong>键</strong>要存储的是自定义对象，需要重写hashCode和equals方法。</p>
<p>基于哈希表。增删改查的性能都较好。</p>
<h5 id="LinkedHashMap集合概述和特点"><a href="#LinkedHashMap集合概述和特点" class="headerlink" title="LinkedHashMap集合概述和特点"></a><strong>LinkedHashMap集合概述和特点</strong></h5><p><strong>由键决定：有序</strong>、不重复、无索引。</p>
<p>这里的有序指的是保证存储和取出的元素顺序一致</p>
<p><strong>原理</strong>：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p>
<h5 id="TreeMap集合概述和特点"><a href="#TreeMap集合概述和特点" class="headerlink" title="TreeMap集合概述和特点"></a><strong>TreeMap集合概述和特点</strong></h5><p>由键决定特性：不重复、无索引、可排序</p>
<p>可排序：按照键数据的大小默认升序（有小到大）排序。<strong>只能对键排序。</strong></p>
<p><strong>注意：TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</strong></p>
<p>TreeMap跟TreeSet一样底层原理是一样的。</p>
<p><strong>TreeMap集合自定义排序规则有2种</strong></p>
<p>类实现Comparable接口，重写比较规则。</p>
<p>集合自定义Comparator比较器对象，重写比较规则。</p>
<h5 id="Map集合实现类特点"><a href="#Map集合实现类特点" class="headerlink" title="Map集合实现类特点"></a><strong>Map集合实现类特点</strong></h5><p>HashMap:元素按照键是无序，不重复，无索引，值不做要求，基于哈希表（与Map体系一致）</p>
<p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求，基于哈希表</p>
<p>TreeMap：元素只能按照键<strong>排序</strong>，不重复，无索引的，值不做要求，可以做排序</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">一.第一段程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">二.变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">三.数据转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">四.方法的定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.</span> <span class="toc-text">五.选择语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">六.循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">七.数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">8.</span> <span class="toc-text">八.动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.</span> <span class="toc-text">九.字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">十.类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">十一.抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E8%BD%AC%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">十二.转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.</span> <span class="toc-text">十三.接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-this%E5%92%8Csuper%E4%B8%93%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">十四.this和super专题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-final%E4%B8%93%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">十五.final专题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-public-protect-default-private-static-final-abstract"><span class="toc-number">16.</span> <span class="toc-text">十六.public protect  default private static final abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-%E5%B8%B8%E7%94%A8api"><span class="toc-number">17.</span> <span class="toc-text">十七.常用api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-number">17.1.</span> <span class="toc-text">object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objects%E7%B1%BB"><span class="toc-number">17.2.</span> <span class="toc-text">objects类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">17.3.</span> <span class="toc-text">StringBuilder类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date-%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">17.4.</span> <span class="toc-text">Date 类概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat%E7%B1%BB"><span class="toc-number">17.5.</span> <span class="toc-text">SimpleDateFormat类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">17.6.</span> <span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">17.7.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">17.8.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">17.9.</span> <span class="toc-text">Arrays类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-%E9%9B%86%E5%90%88"><span class="toc-number">18.</span> <span class="toc-text">十八.集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection-API"><span class="toc-number">18.1.</span> <span class="toc-text">Collection API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">18.2.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">18.2.1.</span> <span class="toc-text">方式一：迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aforeach-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">18.2.2.</span> <span class="toc-text">方式二：foreach&#x2F;增强for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">18.2.3.</span> <span class="toc-text">方式三：lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">18.3.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList"><span class="toc-number">18.3.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList"><span class="toc-number">18.3.2.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">18.3.3.</span> <span class="toc-text">泛型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">18.4.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet"><span class="toc-number">18.4.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">18.4.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeSet"><span class="toc-number">18.4.3.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">18.5.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">18.6.</span> <span class="toc-text">Collections 集合工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAP%E9%9B%86%E5%90%88"><span class="toc-number">18.7.</span> <span class="toc-text">MAP集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.1.</span> <span class="toc-text">HashMap的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashMap%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.2.</span> <span class="toc-text">LinkedHashMap集合概述和特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TreeMap%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.3.</span> <span class="toc-text">TreeMap集合概述和特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="toc-number">18.7.4.</span> <span class="toc-text">Map集合实现类特点</span></a></li></ol></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




</html>
