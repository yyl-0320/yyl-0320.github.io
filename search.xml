<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++</title>
    <url>/2022/09/18/C/</url>
    <content><![CDATA[<h3 id="一-第一段程序"><a href="#一-第一段程序" class="headerlink" title="一.第一段程序"></a>一.第一段程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">//基本变量:</span></span><br><span class="line">        byte num2=<span class="number">35</span>;         <span class="comment">//字节型      1个字节   -128~127</span></span><br><span class="line">        <span class="type">short</span> num3=<span class="number">50</span>;        <span class="comment">//短整型      2个字节   -32768~32767</span></span><br><span class="line">    	<span class="type">unsigned</span> <span class="type">short</span> num7=<span class="number">8</span> <span class="comment">//           1个字节</span></span><br><span class="line">        <span class="type">int</span> num1=<span class="number">10</span>;          <span class="comment">//整形        4个字节   -2^31~2^31-1</span></span><br><span class="line">    	<span class="type">unsigned</span> <span class="type">int</span>          <span class="comment">//           4个字节</span></span><br><span class="line">        <span class="type">long</span> num4=<span class="number">3000000L</span>;   <span class="comment">//长整型      4个字节   -2^63~2^63-1      后面要加L</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>         <span class="comment">//           4个字节</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span>             <span class="comment">//           8个字节</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>    <span class="comment">//           8个字节</span></span><br><span class="line">    	<span class="type">float</span> num5=<span class="number">2.5F</span>;      <span class="comment">//单精度浮点数  4个字节   1.4013E-45~3.4028E+38  后边要加F</span></span><br><span class="line">        <span class="type">double</span> num6=<span class="number">1.2</span>;      <span class="comment">//双精度浮点型   8个字节  4.9E-324~1.7977E+308</span></span><br><span class="line">        <span class="type">long</span> <span class="type">double</span>           <span class="comment">//                     12个字节</span></span><br><span class="line">    	<span class="type">char</span> zifu1=<span class="string">&#x27;S&#x27;</span>;       <span class="comment">//字符型        1个字节  0~65535</span></span><br><span class="line">    	<span class="type">signed</span> <span class="type">char</span> zifu2=<span class="string">&#x27;s&#x27;</span> <span class="comment">//             1个字节</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> zifu3=<span class="string">&#x27;s&#x27;</span><span class="comment">//            1个字节</span></span><br><span class="line">        <span class="type">wchar_t</span> zifu4=<span class="string">&#x27;s&#x27;</span>      <span class="comment">//             2个字节</span></span><br><span class="line">        <span class="type">bool</span> var1=<span class="literal">true</span>;        <span class="comment">//布尔类型      1个字节  true false</span></span><br><span class="line">                               <span class="comment">//*            8字节</span></span><br><span class="line">    	<span class="comment">//复合变量:</span></span><br><span class="line">    	<span class="type">int</span> num1=<span class="number">12</span>;</span><br><span class="line">    	<span class="type">int</span> &amp;num_1=num1;        <span class="comment">//相当于num1的另一个别名   对num_1的操作相当于对num1的</span></span><br><span class="line">    	<span class="type">int</span> &amp;num_2=<span class="number">12</span>;          <span class="comment">//不可以赋值为具体数</span></span><br><span class="line">    	<span class="type">int</span> *p=&amp;num1            <span class="comment">//指针     NULL:预处理变量 nullptr:特殊类型的字面值</span></span><br><span class="line">        <span class="type">int</span> *&amp;r=&amp;num1           <span class="comment">//指针引用  r相当于p</span></span><br><span class="line">        <span class="comment">//const:</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> num1=<span class="number">1</span>        <span class="comment">//numl不可改变</span></span><br><span class="line">        <span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> num1=<span class="number">1</span> <span class="comment">//其他文件可以访问</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> &amp;r1 =num1;    <span class="comment">/* 都是合法的</span></span><br><span class="line"><span class="comment">    	const int &amp;r2 =1;        因为相当于const int &amp;r =temp;  指向了一个临时量 </span></span><br><span class="line"><span class="comment">    	const int &amp;r3 =num1*2;  */</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> *p1=&amp;num1;	<span class="comment">//p1 是int常量的指针   底层const                指针常量意味着指针不能变</span></span><br><span class="line">    	<span class="type">int</span> *<span class="type">const</span> p2=&amp;num1;	<span class="comment">//p2 是一个int的常量指针   顶层const             指向int常量意味着 指针不能改变指向的内容的值</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3=&amp;num1;<span class="comment">//p3是一个int常量的常量指针  即时顶层也是底层const          </span></span><br><span class="line">    	<span class="comment">//constexpr:是常量且编译时就能得到结果</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">int</span> *p=&amp;num;		  <span class="comment">//底层const</span></span><br><span class="line">    	<span class="keyword">constexpr</span> <span class="type">int</span> *p=&amp;num;    <span class="comment">//顶层const</span></span><br><span class="line">    	<span class="comment">//类型别名:</span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="type">int</span> int1;         <span class="comment">//int1是int的同义词</span></span><br><span class="line">    	<span class="keyword">using</span> int1=<span class="type">int</span>;           <span class="comment">//int1是int的同义词</span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="type">int</span> *int2;        <span class="comment">//意思是int2是一个int的指针类型 相当于int*  但是 const int2 p =&amp;num;</span></span><br><span class="line">    																	   <span class="comment">// const int *p=&amp;num;</span></span><br><span class="line">    								<span class="comment">//                             二者并不相同  前者是顶层const 后者是底层const</span></span><br><span class="line">    	<span class="comment">//auto</span></span><br><span class="line">    	<span class="keyword">auto</span> num1=<span class="number">12</span>;               <span class="comment">//auto会自动识别类型,但是会忽略顶层const</span></span><br><span class="line">    	<span class="type">const</span> <span class="keyword">auto</span> num1=<span class="number">12</span>;         <span class="comment">//需要自己声明</span></span><br><span class="line">    	<span class="comment">//decltype</span></span><br><span class="line">    	<span class="type">int</span> num1 =<span class="number">12</span>;</span><br><span class="line">    	<span class="type">int</span> &amp;num= num1;</span><br><span class="line">    	<span class="keyword">decltype</span> (num1) n;              <span class="comment">// n是int</span></span><br><span class="line">    	<span class="keyword">decltype</span> ((num1)) n;            <span class="comment">//n是int&amp;  即引用</span></span><br><span class="line">    	<span class="keyword">decltype</span> (num)   n;             <span class="comment">//n是int&amp;</span></span><br><span class="line">    	<span class="keyword">decltype</span> (num+<span class="number">0</span>)  n;            <span class="comment">//n是int		</span></span><br><span class="line">        </span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-数据转换"><a href="#三-数据转换" class="headerlink" title="三.数据转换"></a>三.数据转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="string">u&#x27;sd&#x27;</span>               <span class="comment">//char12_t</span></span><br><span class="line">        <span class="string">U&#x27;s&#x27;</span>                <span class="comment">//char32_t</span></span><br><span class="line">        <span class="string">L&#x27;s&#x27;</span>                <span class="comment">//wchar_t</span></span><br><span class="line">        <span class="string">u8&#x27;s&#x27;</span>               <span class="comment">//unf-8  char</span></span><br><span class="line">        <span class="number">12u</span>                 <span class="comment">//unsigned</span></span><br><span class="line">        <span class="number">12l</span>                 <span class="comment">//long</span></span><br><span class="line">        <span class="number">12ll</span>                <span class="comment">//long long</span></span><br><span class="line">        <span class="number">12.2f</span>               <span class="comment">//float</span></span><br><span class="line">        <span class="number">12.2l</span>               <span class="comment">//long double</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-方法的定义与调用"><a href="#四-方法的定义与调用" class="headerlink" title="四.方法的定义与调用"></a>四.方法的定义与调用</h3><h3 id="五-选择语句"><a href="#五-选择语句" class="headerlink" title="五.选择语句"></a>五.选择语句</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         </span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//if:</span></span><br><span class="line">    <span class="keyword">if</span>()                     <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    &#123;&#125;                 </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;&#125;                       <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">     <span class="comment">//switch:</span></span><br><span class="line">     <span class="keyword">switch</span>(<span class="number">5</span>)&#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六-循环语句"><a href="#六-循环语句" class="headerlink" title="六.循环语句"></a>六.循环语句</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>            </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;           </span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>,nums=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//while:</span></span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(++val&lt;=<span class="number">10</span>)           <span class="comment">//循环十次</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums+=val;             <span class="comment">// nums = nums + val;</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span>;             <span class="comment">//break 跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span>;         <span class="comment">//continue 结束本次循环,开始下次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;val)</span><br><span class="line">        nums+=val;            <span class="comment">//循环一直进行直达遇到 文件结束符或者错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val= <span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">        nums+=val;</span><br><span class="line">    <span class="comment">//do...while:</span></span><br><span class="line">    <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>()               <span class="comment">//至少进行一次循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七-数组"><a href="#七-数组" class="headerlink" title="七.数组"></a>七.数组</h3><h3 id="八-类和对象"><a href="#八-类和对象" class="headerlink" title="八.类和对象"></a>八.类和对象</h3><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>              <span class="comment">//输入流istream 和输出流ostream</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;                     <span class="comment">//标准库所有的名字都在namespace std 中</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;adf&quot;</span>&lt;&lt;std::end1;  <span class="comment">//cout 标准输出  等价于 (std::cout&lt;&lt;&quot;adf&quot;)&lt;&lt;std::end1;  </span></span><br><span class="line">    <span class="type">int</span> n;                      </span><br><span class="line">    std::cin&gt;&gt;v1;                <span class="comment">//cin  标准输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;                  <span class="comment">//定义结构体</span></span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;            </span><br><span class="line">	student st1;</span><br><span class="line">    st1.id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义头文件"><a href="#定义头文件" class="headerlink" title="定义头文件"></a>定义头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> head.h                  <span class="comment">//若没有定义则执行    ifdef</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> head.h                  <span class="comment">//定义head.h</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;                 <span class="comment">/*防止重复定义*/</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++</title>
    <url>/2024/03/06/C++/</url>
    <content><![CDATA[<p>一.第一段程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main ()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二.变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    	//基本变量:</span><br><span class="line">        byte num2=35;         //字节型      1个字节   -128~127</span><br><span class="line">        short num3=50;        //短整型      2个字节   -32768~32767</span><br><span class="line">    	unsigned short num7=8 //           1个字节</span><br><span class="line">        int num1=10;          //整形        4个字节   -2^31~2^31-1</span><br><span class="line">    	unsigned int          //           4个字节</span><br><span class="line">        long num4=3000000L;   //长整型      4个字节   -2^63~2^63-1      后面要加L</span><br><span class="line">        unsigned long         //           4个字节</span><br><span class="line">        long long             //           8个字节</span><br><span class="line">        unsigned long long    //           8个字节</span><br><span class="line">    	float num5=2.5F;      //单精度浮点数  4个字节   1.4013E-45~3.4028E+38  后边要加F</span><br><span class="line">        double num6=1.2;      //双精度浮点型   8个字节  4.9E-324~1.7977E+308</span><br><span class="line">        long double           //                     12个字节</span><br><span class="line">    	char zifu1=&#x27;S&#x27;;       //字符型        1个字节  0~65535</span><br><span class="line">    	signed char zifu2=&#x27;s&#x27; //             1个字节</span><br><span class="line">        unsigned char zifu3=&#x27;s&#x27;//            1个字节</span><br><span class="line">        wchar_t zifu4=&#x27;s&#x27;      //             2个字节</span><br><span class="line">        bool var1=true;        //布尔类型      1个字节  true false</span><br><span class="line">                               //*            8字节</span><br><span class="line">    	//复合变量:</span><br><span class="line">    	int num1=12;</span><br><span class="line">    	int &amp;num_1=num1;        //相当于num1的另一个别名   对num_1的操作相当于对num1的</span><br><span class="line">    	int &amp;num_2=12;          //不可以赋值为具体数</span><br><span class="line">    	int *p=&amp;num1            //指针     NULL:预处理变量 nullptr:特殊类型的字面值</span><br><span class="line">        int *&amp;r=&amp;num1           //指针引用  r相当于p</span><br><span class="line">        //const:</span><br><span class="line">        const int num1=1        //numl不可改变</span><br><span class="line">        extern const int num1=1 //其他文件可以访问</span><br><span class="line">        const int &amp;r1 =num1;    /* 都是合法的</span><br><span class="line">    	const int &amp;r2 =1;        因为相当于const int &amp;r =temp;  指向了一个临时量 </span><br><span class="line">    	const int &amp;r3 =num1*2;  */</span><br><span class="line">    	const int *p1=&amp;num1;	//p1 是int常量的指针   底层const                指针常量意味着指针不能变</span><br><span class="line">    	int *const p2=&amp;num1;	//p2 是一个int的常量指针   顶层const             指向int常量意味着 指针不能改变指向的内容的值</span><br><span class="line">    	const int *const p3=&amp;num1;//p3是一个int常量的常量指针  即时顶层也是底层const          </span><br><span class="line">    	//constexpr:是常量且编译时就能得到结果</span><br><span class="line">    	const int *p=&amp;num;		  //底层const</span><br><span class="line">    	constexpr int *p=&amp;num;    //顶层const</span><br><span class="line">    	//类型别名:</span><br><span class="line">    	typedef int int1;         //int1是int的同义词</span><br><span class="line">    	using int1=int;           //int1是int的同义词</span><br><span class="line">    	typedef int *int2;        //意思是int2是一个int的指针类型 相当于int*  但是 const int2 p =&amp;num;</span><br><span class="line">    																	   // const int *p=&amp;num;</span><br><span class="line">    								//                             二者并不相同  前者是顶层const 后者是底层const</span><br><span class="line">    	//auto</span><br><span class="line">    	auto num1=12;               //auto会自动识别类型,但是会忽略顶层const</span><br><span class="line">    	const auto num1=12;         //需要自己声明</span><br><span class="line">    	//decltype</span><br><span class="line">    	int num1 =12;</span><br><span class="line">    	int &amp;num= num1;</span><br><span class="line">    	decltype (num1) n;              // n是int</span><br><span class="line">    	decltype ((num1)) n;            //n是int&amp;  即引用</span><br><span class="line">    	decltype (num)   n;             //n是int&amp;</span><br><span class="line">    	decltype (num+0)  n;            //n是int		</span><br><span class="line">        </span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三.数据转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">        u&#x27;sd&#x27;               //char12_t</span><br><span class="line">        U&#x27;s&#x27;                //char32_t</span><br><span class="line">        L&#x27;s&#x27;                //wchar_t</span><br><span class="line">        u8&#x27;s&#x27;               //unf-8  char</span><br><span class="line">        12u                 //unsigned</span><br><span class="line">        12l                 //long</span><br><span class="line">        12ll                //long long</span><br><span class="line">        12.2f               //float</span><br><span class="line">        12.2l               //long double</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四.方法的定义与调用</p>
<p>五.选择语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x #include &lt;iostream&gt;         </span><br><span class="line">    int main()&#123;</span><br><span class="line">    //if:</span><br><span class="line">    if()                     //若满足条件则执行后面的语句</span><br><span class="line">    &#123;&#125;                 </span><br><span class="line">    else if()</span><br><span class="line">    &#123;&#125;                       //若满足条件则执行后面的语句</span><br><span class="line">    else</span><br><span class="line">    &#123;&#125;</span><br><span class="line">     //switch:</span><br><span class="line">     switch(5)&#123;</span><br><span class="line">         case 1:</span><br><span class="line">             break;</span><br><span class="line">         case 2:</span><br><span class="line">             break;</span><br><span class="line">         case 3:</span><br><span class="line">             break;</span><br><span class="line">         case 4:</span><br><span class="line">             break;</span><br><span class="line">         case 5:</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>六.循环语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;            </span><br><span class="line">int main ()&#123;           </span><br><span class="line">    int val=0,nums=0;</span><br><span class="line">    //while:</span><br><span class="line">    int val=0,nums=0;</span><br><span class="line">	while(++val&lt;=10)           //循环十次</span><br><span class="line">    &#123;</span><br><span class="line">        nums+=val;             // nums = nums + val;</span><br><span class="line">        if(val==5)</span><br><span class="line">            break;             //break 跳出循环</span><br><span class="line">        if(val==3)</span><br><span class="line">            continue;         //continue 结束本次循环,开始下次</span><br><span class="line">    &#125;</span><br><span class="line">    while(std::cin&gt;&gt;val)</span><br><span class="line">        nums+=val;            //循环一直进行直达遇到 文件结束符或者错误</span><br><span class="line">    &#125;</span><br><span class="line">    //for循环</span><br><span class="line">    int nums=0;</span><br><span class="line">    for(int val= 1;val&lt;=10;++val)</span><br><span class="line">        nums+=val;</span><br><span class="line">    //do...while:</span><br><span class="line">    do&#123;&#125;while()               //至少进行一次循环</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>七.数组</p>
<p>八.类和对象</p>
<p>输入与输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;              //输入流istream 和输出流ostream</span><br><span class="line">int main ()&#123;                     //标准库所有的名字都在namespace std 中</span><br><span class="line">    std::cout&lt;&lt;&quot;adf&quot;&lt;&lt;std::end1;  //cout 标准输出  等价于 (std::cout&lt;&lt;&quot;adf&quot;)&lt;&lt;std::end1;  </span><br><span class="line">    int n;                      </span><br><span class="line">    std::cin&gt;&gt;v1;                //cin  标准输入</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">struct student&#123;                  //定义结构体</span><br><span class="line">  int id;</span><br><span class="line">   int age;</span><br><span class="line">&#125;;</span><br><span class="line">int main ()&#123;            </span><br><span class="line">	student st1;</span><br><span class="line">    st1.id=0;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef head.h                  //若没有定义则执行    ifdef</span><br><span class="line">#define head.h                  //定义head.h</span><br><span class="line">struct student&#123;                 /*防止重复定义*/</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>JAVA</title>
    <url>/2022/09/18/JAVA/</url>
    <content><![CDATA[<h3 id="一-第一段程序"><a href="#一-第一段程序" class="headerlink" title="一.第一段程序"></a>一.第一段程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;                            <span class="comment">//文件名字要与类名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-变量"><a href="#二-变量" class="headerlink" title="二.变量"></a>二.变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">num</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">byte</span> num2=<span class="number">35</span>;      <span class="comment">//字节型      1个字节   -128~127</span></span><br><span class="line">        <span class="type">short</span> num3=<span class="number">50</span>;     <span class="comment">//短整型      2个字节   -32768~32767</span></span><br><span class="line">        <span class="type">int</span> num1=<span class="number">10</span>;       <span class="comment">//整形        4个字节   -2^31~2^31-1</span></span><br><span class="line">        <span class="type">long</span> num4=<span class="number">3000000L</span>;<span class="comment">//长整型      8个字节   -2^63~2^63-1      后面要加L</span></span><br><span class="line">        <span class="type">float</span> numm5=<span class="number">2.5F</span>;  <span class="comment">//单精度浮点数  4个字节   1.4013E-45~3.4028E+38  后边要加F</span></span><br><span class="line">        <span class="type">double</span> num6=<span class="number">1.2</span>;   <span class="comment">//双精度浮点型   8个字节  4.9E-324~1.7977E+308</span></span><br><span class="line">        <span class="type">char</span> zifu1=<span class="string">&#x27;S&#x27;</span>;    <span class="comment">//字符型        2个字节  0~65535</span></span><br><span class="line">        <span class="type">boolean</span> var1=<span class="literal">true</span>; <span class="comment">//布尔类型      一个字节  true false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-数据转换"><a href="#三-数据转换" class="headerlink" title="三.数据转换"></a>三.数据转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">num</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//自动转换:</span></span><br><span class="line">        <span class="type">long</span> num1=<span class="number">100</span>;     <span class="comment">//右边int 类型比左边数据范围小.自动转为long</span></span><br><span class="line">        <span class="type">double</span> num2=<span class="number">2.5F</span>;  <span class="comment">//右边float 类型比左边数据范围小.自动转为double</span></span><br><span class="line">        <span class="type">float</span> num3=<span class="number">30L</span> ;   <span class="comment">//右边long 类型比左边数据范围小.自动转为float</span></span><br><span class="line">        <span class="comment">//强制转换:</span></span><br><span class="line">        <span class="type">int</span> num=(<span class="type">int</span>) <span class="number">100L</span>;<span class="comment">//强制转换</span></span><br><span class="line">        a+=<span class="number">2</span>               <span class="comment">//a=a+2</span></span><br><span class="line">        a&gt;b ? a:b          <span class="comment">//若前边为真则取a;否则取b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-方法的定义与调用"><a href="#四-方法的定义与调用" class="headerlink" title="四.方法的定义与调用"></a>四.方法的定义与调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">four</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        printf();                           <span class="comment">//方法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">()</span>&#123;            <span class="comment">//方法定义</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;    <span class="comment">//返回int类型</span></span><br><span class="line">        <span class="type">int</span> sum=a+b;</span><br><span class="line">        <span class="keyword">return</span> sum;                         <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="title function_">sum</span><span class="params">(<span class="type">byte</span> a,<span class="type">byte</span> b)</span>&#123; <span class="comment">//函数重载   只和名字和参数相同 要求名字相同但参数不同(数量,类型等)</span></span><br><span class="line">        <span class="type">byte</span> sum=(<span class="type">byte</span>)(a+b);</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-选择语句"><a href="#五-选择语句" class="headerlink" title="五.选择语句"></a>五.选择语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifelse</span>&#123;                            <span class="comment">//文件名字要与类名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//if:</span></span><br><span class="line">    <span class="keyword">if</span>()                     <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    &#123;&#125;                 </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;&#125;                       <span class="comment">//若满足条件则执行后面的语句</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">     <span class="comment">//switch:</span></span><br><span class="line">     <span class="keyword">switch</span>(<span class="number">5</span>)&#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六-循环语句"><a href="#六-循环语句" class="headerlink" title="六.循环语句"></a>六.循环语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifelse</span>&#123;                          </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//while:</span></span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>,nums=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(++val&lt;=<span class="number">10</span>)           <span class="comment">//循环十次</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums+=val;             <span class="comment">// nums = nums + val;</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span>;             <span class="comment">//break 跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(val==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span>;         <span class="comment">//continue 结束本次循环,开始下次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;val)</span><br><span class="line">        nums+=val;            <span class="comment">//循环一直进行直达遇到 文件结束符或者错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val= <span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">        nums+=val;</span><br><span class="line">    <span class="comment">//do...while:</span></span><br><span class="line">    <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>()               <span class="comment">//至少进行一次循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七-数组"><a href="#七-数组" class="headerlink" title="七.数组"></a>七.数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">array</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> [] array1=<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">100</span>];           <span class="comment">//动态初始化存一百个int 的数组</span></span><br><span class="line">        <span class="type">int</span> [] array2=<span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;    <span class="comment">//静态初始化</span></span><br><span class="line">        <span class="type">int</span> [] array3=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;               <span class="comment">//静态初始化省略</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">let</span> <span class="operator">=</span>array.length;                 <span class="comment">//数组长度</span></span><br><span class="line">        classname [] array=<span class="keyword">new</span> <span class="title class_">classname</span>[<span class="number">3</span>];   <span class="comment">//对象数组</span></span><br><span class="line">        <span class="type">classname</span> <span class="variable">one</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">classname</span>();</span><br><span class="line">        array[<span class="number">0</span>]=one;                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八-动态数组"><a href="#八-动态数组" class="headerlink" title="八.动态数组"></a>八.动态数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	ArrayList&lt;string&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();       <span class="comment">//构造动态数组</span></span><br><span class="line">    list.add(<span class="string">&quot;三天后&quot;</span>);                               <span class="comment">//从最后面插入元素</span></span><br><span class="line">        基本类型      包装类</span><br><span class="line">          <span class="type">byte</span>     Byte</span><br><span class="line">          <span class="type">short</span>    Short</span><br><span class="line">          <span class="type">int</span>       Integer</span><br><span class="line">          <span class="type">long</span>      Long</span><br><span class="line">          <span class="type">float</span>     Float</span><br><span class="line">          <span class="type">double</span>    Double</span><br><span class="line">          <span class="type">char</span>       Character</span><br><span class="line">          <span class="type">boolean</span>    Boolean </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九-字符串"><a href="#九-字符串" class="headerlink" title="九.字符串"></a>九.字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">string</span>&#123;</span><br><span class="line">    pubiic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1.字符串不可变</span></span><br><span class="line"><span class="comment">     2.字符串可共享</span></span><br><span class="line"><span class="comment">     3.字符串表现为char []数组,但实际上底层原理是byte[] 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     构造方法</span></span><br><span class="line"><span class="comment">     1.public String()                        //构造空字符串</span></span><br><span class="line"><span class="comment">     2.public String(char [] array)           //使用字符数组创建,地址指向字符数组再指向byte[]</span></span><br><span class="line"><span class="comment">     3.public String(byte [] array)</span></span><br><span class="line"><span class="comment">     4.string char=&quot;afhjg&quot;                    //地址指向字符串常量池,再指向字符数组再指向byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     使用方法</span></span><br><span class="line"><span class="comment">     1.public boolean equals(object obj)      //比较</span></span><br><span class="line"><span class="comment">     2.public int Length()                    //获取长度</span></span><br><span class="line"><span class="comment">     3.public String concat(String str)       //拼接字符串</span></span><br><span class="line"><span class="comment">     4.public char charAt(int index)          //获取指定位置字符串</span></span><br><span class="line"><span class="comment">     5.public int indexOf(String str)         //查找子串出现位置</span></span><br><span class="line"><span class="comment">     6.public String substring(int index)     //从参数位置开始截取到尾部</span></span><br><span class="line"><span class="comment">     7.public String substring(int begin,int end)//截取范围内字符串,前闭后开</span></span><br><span class="line"><span class="comment">     8.public char[] toCharArray()             //转换成Char数组</span></span><br><span class="line"><span class="comment">     9.public byte getBytes()                  //获取底层byte数组</span></span><br><span class="line"><span class="comment">     10.public String replace(CharSequencr oldString,CharSequencr NewString)//替换</span></span><br><span class="line"><span class="comment">     11.public String[] split(String reget)    //按指定参数分割字符串       &quot;,&quot; &quot; &quot;  //.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十-类和对象"><a href="#十-类和对象" class="headerlink" title="十.类和对象"></a>十.类和对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line">	<span class="comment">/*封装性 继承性 多态性*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1.所有成员变量都要用private</span></span><br><span class="line"><span class="comment">      2.成员变量的set和get函数</span></span><br><span class="line"><span class="comment">      3.无参构造函数            不写会赠送</span></span><br><span class="line"><span class="comment">      4.全参构造函数*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>&#123;                        <span class="comment">//定义类 </span></span><br><span class="line">    String name;                             <span class="comment">//属性定义在方法外面</span></span><br><span class="line">    <span class="type">int</span> age=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rage;                        <span class="comment">// 类外无法直接访问 通过定义方法间接访问</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> classroom;                    <span class="comment">//静态类型</span></span><br><span class="line">    <span class="built_in">this</span>.name;                               <span class="comment">//指类内的属性值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;                      <span class="comment">//方法不加static</span></span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat1</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;eat1&quot;</span>);         <span class="comment">//静态方法可以通过  student.eat1直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span>&#123;&#125;                      <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;    <span class="comment">//有参构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;System.out.println(<span class="string">&quot;第一次构造&quot;</span>);&#125; <span class="comment">//静态代码块在第一次构造时唯一使用一次</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。</span></span><br><span class="line"><span class="comment">例如：身体和心脏的关系。又如：汽车和发动机的关系。</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">1.成员内部类</span></span><br><span class="line"><span class="comment">2.局部内部类（包含匿名内部类）</span></span><br><span class="line"><span class="comment">成员内部类的定义格式：</span></span><br><span class="line"><span class="comment">修饰符class外部类名称f</span></span><br><span class="line"><span class="comment">修饰符class内部类名称f</span></span><br><span class="line"><span class="comment">注意：内用外，随意访问；外用内，需要内部类对象。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*继承特点: 单一继承性 多级继承性 多子类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">senerstudent</span> extend studend&#123;   <span class="comment">//定义子类继承父类</span></span><br><span class="line">    <span class="type">int</span> age=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">40</span>;</span><br><span class="line">    		System.out.println(age);       <span class="comment">//方法中的40</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.age);  <span class="comment">//类中的30</span></span><br><span class="line">            System.out.println(<span class="built_in">super</span>.age); <span class="comment">//父类的20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">senerstudent</span><span class="params">()</span>&#123;                 <span class="comment">//子类无参构造</span></span><br><span class="line">        <span class="built_in">super</span>();                           <span class="comment">//调用父类有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">senerstudent</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">50</span>)                   <span class="comment">//调用父类有参构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*方法覆盖重写的注意事项</span></span><br><span class="line"><span class="comment">		1.必须保证父子类之间方法的名称相同，参数列表也相同</span></span><br><span class="line"><span class="comment">		@override：写在方法前面，用来检测是不是有效的正确覆盖重写</span></span><br><span class="line"><span class="comment">		这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</span></span><br><span class="line"><span class="comment">		2.子类方法的返回值必须【小于等于】父类方法的返回值范围。</span></span><br><span class="line"><span class="comment">		小扩展提示：java.lang.object类是所有类的公共最高父类（祖宗类），java.lang.string就是object的子类</span></span><br><span class="line"><span class="comment">		3.子类方法的权限必须【大于等于】类方法的权限修饰符。</span></span><br><span class="line"><span class="comment">		小扩展提示：public&gt;protected&gt;（default）&gt;private</span></span><br><span class="line"><span class="comment">		备注：（default）不是关键字default，而是什么都不写，留空。*/</span></span><br><span class="line">    <span class="comment">/*继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment">	1.子类构造方法当中有一个默认隐含的“super（）调用，所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">	2.子类构造可以通过super关键字来调用父类重载构造。</span></span><br><span class="line"><span class="comment">	3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">	总结：</span></span><br><span class="line"><span class="comment">	子类必须调用父类构造方法，不写则赠送super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多态性*/</span></span><br><span class="line"><span class="comment">/*代码当中体现多态性，其实就是一句话：父类引用指向子类对象。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">父类概称对象名=new子类名称（）；</span></span><br><span class="line"><span class="comment">或者：</span></span><br><span class="line"><span class="comment">接口名称</span></span><br><span class="line"><span class="comment">对象名=new实现类名称（）；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*在多态的代码当中，成员方法的访问规则是：</span></span><br><span class="line"><span class="comment">看new的是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看右边。</span></span><br><span class="line"><span class="comment">对比一下：</span></span><br><span class="line"><span class="comment">成员变量：</span></span><br><span class="line"><span class="comment">编译看左边，运行还看左边。</span></span><br><span class="line"><span class="comment">成员方法：编译看左边，运行看右边。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String【】args)</span>&#123;</span><br><span class="line"><span class="comment">//使用多态的写法</span></span><br><span class="line"><span class="comment">//左侧父类的引用，指向了右侧子类的对象</span></span><br><span class="line">Fu obj= <span class="keyword">new</span> <span class="title class_">zi</span>（）;                     <span class="comment">//多态性</span></span><br><span class="line">obj.method（）;                         <span class="comment">//zi fu 都有 用子</span></span><br><span class="line">obj.methodFu（）;                       <span class="comment">//子无用父</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果不用多态，只用子类，那么写法是：</span></span><br><span class="line"><span class="comment">Teacher one new Teacher();</span></span><br><span class="line"><span class="comment">one.work():/∥讲课</span></span><br><span class="line"><span class="comment">Assistant two new Assistant();</span></span><br><span class="line"><span class="comment">two.work():/∥辅导</span></span><br><span class="line"><span class="comment">我现在唯一要做的事情，就是调用work方法，其他的功能不关心。</span></span><br><span class="line"><span class="comment">如果使用多态的写法，对比一下：</span></span><br><span class="line"><span class="comment">Employee one new TeacherO;</span></span><br><span class="line"><span class="comment">one,work():/∥讲课</span></span><br><span class="line"><span class="comment">Employee two new AssistantO;</span></span><br><span class="line"><span class="comment">two.work();/∥辅导</span></span><br><span class="line"><span class="comment">好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类</span></span><br><span class="line"><span class="keyword">import</span> 路径.student                         <span class="comment">//导入包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">std</span>&#123;                           </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">student</span> <span class="variable">std</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();       <span class="comment">//使用无参构造函数定义对象</span></span><br><span class="line">        std.name=<span class="string">&quot;阿凡达&quot;</span>;                  <span class="comment">//定义对象属性</span></span><br><span class="line">        std.age=<span class="number">100</span>;</span><br><span class="line">        std.eat();                         <span class="comment">//使用对象方法</span></span><br><span class="line">        student std1= <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;阿发说&quot;</span>,<span class="number">12</span>);<span class="comment">//使用全参构造函数定义对象</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十一-抽象类和抽象方法"><a href="#十一-抽象类和抽象方法" class="headerlink" title="十一.抽象类和抽象方法"></a>十一.抽象类和抽象方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class,之前写上abstract即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> eat（）;</span><br><span class="line"><span class="comment">//这是普通的成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> normalMethod（）&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1.不能直接创建new抽象类对象</span></span><br><span class="line"><span class="comment">2.必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3.子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4.创建子类对象进行使用。|*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> eat（）</span><br><span class="line">System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十二-转型"><a href="#十二-转型" class="headerlink" title="十二.转型"></a>十二.转型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>对象的向上转型，其实就是多态写法：</span><br><span class="line">格式：父类名称对象名=<span class="keyword">new</span>子类名称():</span><br><span class="line">Animal animal <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">含义：右侧创建一个子类对象，把它当做父类来看待使用。</span><br><span class="line">创建了一只猫，当做动物看待，没问题。</span><br><span class="line">注意事项：向上转型一定是安全的。从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。</span><br><span class="line">    </span><br><span class="line">向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：</span><br><span class="line">对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。</span><br><span class="line">解决方案：用对象的向下转型[还原]</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对象的向下转型，其实是一个【还原】的动作。</span><br><span class="line">格式：子类名称对象名=（子类名称父类对象：</span><br><span class="line">含义：将父类对象，</span><br><span class="line">【还原】成为本来的子类对象。</span><br><span class="line">Animal animal=<span class="keyword">new</span> <span class="title class_">Cat</span>():/本来是猫，向上转型成为动物</span><br><span class="line">Catcat=(Cat)animal;;/∥本来是猫，已经被当做动物了，还原回来成为本来的猫</span><br><span class="line">注意事项：</span><br><span class="line">.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。</span><br><span class="line">b.如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错。ClassCastException</span><br><span class="line">    </span><br><span class="line">如何才能知道一个父类引用的对象，本来是什么子类？</span><br><span class="line">格式：</span><br><span class="line">对象<span class="keyword">instanceof</span>类名称</span><br><span class="line">这将会得到一个<span class="type">boolean</span>值结果，也就是判断前面的对象能不能当做后面类型的实例。</span><br></pre></td></tr></table></figure>



<h3 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口就是多个类的公共规范。</span></span><br><span class="line"><span class="comment">接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。</span></span><br><span class="line"><span class="comment">如何定义一个接口的格式：</span></span><br><span class="line"><span class="comment">public interface接口名称&#123;</span></span><br><span class="line"><span class="comment">//接口内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">备注：换成了关键字interface.之后，编译生成的字节码文件仍然是：。java--&gt;.class.</span></span><br><span class="line"><span class="comment">如果是Java7,那么接口中可以包含的内容有：</span></span><br><span class="line"><span class="comment">1.常量</span></span><br><span class="line"><span class="comment">2.抽象方法</span></span><br><span class="line"><span class="comment">如果是Java8,还可以额外包含有：</span></span><br><span class="line"><span class="comment">3.默认方法</span></span><br><span class="line"><span class="comment">4.静态方法</span></span><br><span class="line"><span class="comment">果是JavaT9,还可以额外包含有：</span></span><br><span class="line"><span class="comment">5.私有方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*接口使用步骤：</span></span><br><span class="line"><span class="comment">1.接口不能直接使用，必须有一个实现类来实现该接口。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口名称()</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。</span></span><br><span class="line"><span class="comment">实现：去掉abstract关键字，加上方法体大括号。</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">创建实现类的对象，进行使用。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.接口的默认方法，可以通过接口实现类对象，直接调用</span></span><br><span class="line"><span class="comment">2.接口的默认方法，也可以被接口实现类进行覆盖重写。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。</span></span><br><span class="line"><span class="comment">正确用法：通过接口名称，直接调用其中的静态方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">接口名称。静态方法名（参数）；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用接口的时候，需要注意：</span></span><br><span class="line"><span class="comment">1.接口是没有静态代码块或者构造方法的。</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</span></span><br><span class="line"><span class="comment">格式</span></span><br><span class="line"><span class="comment">public cLass MyInterfaceImpl implements MyInterfaceA,MyInterfaceB</span></span><br><span class="line"><span class="comment">//覆盖重写所有抽象方法</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。</span></span><br><span class="line"><span class="comment">5.</span></span><br><span class="line"><span class="comment">如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</span></span><br><span class="line"><span class="comment">6.</span></span><br><span class="line"><span class="comment">一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.类与类之间是单继承的。直接父类只有一个。</span></span><br><span class="line"><span class="comment">2.类与接口之间是多实现的。一个类可以实现多个接口。</span></span><br><span class="line"><span class="comment">3.接口与接口之间是多继承的。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.多个父接口当中的抽象方法如果重复，梁关系。</span></span><br><span class="line"><span class="comment">2.多个父接口当中的默认方法如果重复，邪么子接口必须进行默认方法的覆盖重写，[而且带着defaulti关键字]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">usb</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在任何版本的Java中，接口都能定义抽象方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public abstract返回值类型方法名称（参数列表）；</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></span><br><span class="line"><span class="comment">2.这两个关键字修饰符，可以选择性地省略。(今天刚学，所以不推荐。)</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">方法的三要素，可以随意定义。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;          <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;                   <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;                 <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;                          <span class="comment">//抽象方法</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">/*从Java8开始，接口里允许定义默认方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public default返回值类型方法名称（参数列表）&#123;方法体&#125;</span></span><br><span class="line"><span class="comment">备注：接口当中的默认方法，可以解决接口升级的问题。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span>&#123;&#125;          <span class="comment">//默认方法        调用默认方法如果当前类中没有就会向上找</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*从]ava8开始，接口当中允许定义静态方法</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static返回值类型方法名称（参数列表）&#123;&#125;</span></span><br><span class="line"><span class="comment">方法体</span></span><br><span class="line"><span class="comment">提示：就是将abstract或者default换成static即可，带上方法体。*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m6</span><span class="params">()</span>&#123;&#125;           <span class="comment">//静态方法         不能通过类的对象调用只能通过接口名称直接调用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*问题描述：</span></span><br><span class="line"><span class="comment">我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。</span></span><br><span class="line"><span class="comment">但是这个共有方法不应该让实现类使用，应该是私有化的。</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">从Java9开始，接口当中允许定义私有方法。</span></span><br><span class="line"><span class="comment">1.普通私有方法，解决多个默认方法之间重复代码问题</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">方法体&#125;</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">静态私有方法，解决多个静态方法之闸重复代码问题</span></span><br><span class="line"><span class="comment">棉式：</span></span><br><span class="line"><span class="comment">private static返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">方法体&#125;*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。</span></span><br><span class="line"><span class="comment">从效果上看，这其实就是接口的【常量】。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final数据类型常量名称=数据值；</span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">旦使用final关键字进行修饰，说明不可改变。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">接口当中的常量，可以省略public static final,注意：不写也照样是这样。</span></span><br><span class="line"><span class="comment">2.接口当中的常量，必须进行赋值；不能不赋值。</span></span><br><span class="line"><span class="comment">3.接口中常量的名称，使用完全大写的字母，用下划线进行分隔。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//这其实就是一个常量，一旦赋值，不可以修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> NUM_OF_MYCLASS <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十四-this和super专题"><a href="#十四-this和super专题" class="headerlink" title="十四.this和super专题"></a>十四.this和super专题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*super关键字的用法有三种：</span></span><br><span class="line"><span class="comment">1.在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3.在子类的构造方法中，访问父类的构造方法。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*supe关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</span></span><br><span class="line"><span class="comment">1.在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2.在本类的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3.在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种用法当中要注意：</span></span><br><span class="line"><span class="comment">4.this(..·)调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">3.superi和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十五-final专题"><a href="#十五-final专题" class="headerlink" title="十五.final专题"></a>十五.final专题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*finali关键字代表最终、不可改变的。</span></span><br><span class="line"><span class="comment">常见四种用法：</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">可以用来修饰一个类</span></span><br><span class="line"><span class="comment">2.可以用来修饰一个方法</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">还可以用来修饰一个局部变量</span></span><br><span class="line"><span class="comment">4.</span></span><br><span class="line"><span class="comment">还可以用来修饰一个成员变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*当final关键字用来修饰一个类的时候，格式：</span></span><br><span class="line"><span class="comment">public final class类名称f</span></span><br><span class="line"><span class="comment">.</span></span><br><span class="line"><span class="comment">含义：当前这个类不能有任何的子类。（太监类）</span></span><br><span class="line"><span class="comment">注意：一个类如果是fina(的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当fial关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符final</span></span><br><span class="line"><span class="comment">返回值类型方法名称（参数列表）&#123;</span></span><br><span class="line"><span class="comment">/方法体</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">对于类、方法来说，abstracti关键字和final:关键字不能同时使用，因为矛盾。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于局部变量来说</span></span><br><span class="line"><span class="comment">如果类型是基本类型那么不可变的是类型的值</span></span><br><span class="line"><span class="comment">如果类型是引用类型那么不可变的是类型的地址*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。</span></span><br><span class="line"><span class="comment">1.由于成员变量具有默认值，所以用了final.之后必须手动赋值，不会再给默认值了。</span></span><br><span class="line"><span class="comment">2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。</span></span><br><span class="line"><span class="comment">3.</span></span><br><span class="line"><span class="comment">必须保证类当中所有重载的构造方法，都最终会对fna的成员变量进行赋值。*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十六-public-protect-default-private-static-final-abstract"><a href="#十六-public-protect-default-private-static-final-abstract" class="headerlink" title="十六.public protect  default private static final abstract"></a>十六.public protect  default private static final abstract</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、修饰方法的修饰符</span><br><span class="line"><span class="keyword">public</span>:被该修饰符修饰的方法可以被任何类通过对象.方法使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:被该修饰符修饰的方法可以被该类自身、本包中的类、和子类（是子类而非父类）所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:被该修饰符修饰的方法只能被该类使用</span><br><span class="line"></span><br><span class="line">缺省：被该修饰符修饰的方法只能被该类、本包中的类所使用（缺省的意思就是不用写）</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>：被<span class="keyword">static</span>修饰的方法是一个静态方法，可以被类直接使用，可以通过类名.方法名直接调用,<span class="keyword">static</span>可以和<span class="keyword">final</span>一起使用(在类中修饰的<span class="keyword">static</span>方法可以被对象和类名调用,但是在接口中定义的<span class="keyword">static</span>方法只能通过接口名调用)</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span>：被<span class="keyword">abstract</span>修饰的方法，不能写方法体，且该类必须是抽象类,抽象类中可以没有抽象方法，但是有抽象方法的类必须是一个抽象类</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>：被该修饰符修饰的方法不能被重写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、修饰类的修饰符</span><br><span class="line"><span class="keyword">public</span>：被<span class="keyword">public</span>修饰的类可以被任何类所使用（本包、其他包、自身）</span><br><span class="line"></span><br><span class="line">缺省：缺省的意思就是不写权限访问控制符，被此修饰符修饰的类只能被该类自身，本包中的类所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span>：被此修饰符修饰的类是一个抽象类，抽象类是不能被实例化的，(抽象类主要是用来被继承的)，<span class="keyword">abstract</span>不能和<span class="keyword">final</span>同时修饰一个类</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>：用<span class="keyword">final</span>修饰的类表示最终类，该类不能被继承，且该类也不能是一个抽象类</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、修饰成员变量的修饰符</span><br><span class="line"><span class="keyword">public</span>:被该修饰符修饰的成员变量可以被任何类使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:被该修饰符修饰的成员变量能被该类自身、本包中的类、和子类（是子类而非父类）所使用，即用<span class="keyword">protected</span>修饰的属性在其他包中的子类中可以通过子类对象进行访问，不能通过本类对象进行访问</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:被该修饰符修饰的成员变量只能被该类使用</span><br><span class="line"></span><br><span class="line">缺省：被该修饰符修饰的成员变量只能被该类、本包中的类所使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>：被<span class="keyword">static</span>修饰的成员变量可以被类直接使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>:被该修饰符修饰的成员变量是常量</span><br></pre></td></tr></table></figure>

<h3 id="十七-常用api"><a href="#十七-常用api" class="headerlink" title="十七.常用api"></a>十七.常用api</h3><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类。</span></span><br><span class="line"><span class="comment">Object作为所有类的父类，提供了很多常用的方法给每个子类对象拿来使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(object o)</span>      <span class="comment">// 默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址</span></span><br><span class="line">      <span class="comment">//父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息！！ </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equal</span><span class="params">(object o)</span>      <span class="comment">//默认是比较当前对象与另一个对象的地址是否相同，相同返回true,不同返回false</span></span><br><span class="line">      <span class="comment">//为了被子类重写，以便子类自己来定制比较规则（比如比较对象内容）。</span></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="objects类"><a href="#objects类" class="headerlink" title="objects类"></a>objects类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Objects是一个工具类，提供了一些方法去完成一些功能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span>     <span class="comment">//比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Object obj)</span>            <span class="comment">//判断变量是否为null ,为null返回true ,反之</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*StringBuilder概述</span></span><br><span class="line"><span class="comment">StringBuilder是一个可变的字符串的操作类，我们可以把它看成是一个对象容器。</span></span><br><span class="line"><span class="comment">使用StringBuilder的核心作用：操作字符串的性能比String要更高（如拼接、修改等）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span>                          <span class="comment">//创建一个空白的可变的字符串对象，不包含任何内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(String str)</span>                <span class="comment">//创建一个指定字符串内容的可变字符串对象</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(任意类型)</span>         <span class="comment">//添加数据并返回StringBuilder对象本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">reverse</span><span class="params">()</span>                     <span class="comment">//将对象的内容反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>                               <span class="comment">//返回对象内容长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>                       <span class="comment">//通过toString()就可以实现把StringBuilder转换为String</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Date-类概述"><a href="#Date-类概述" class="headerlink" title="Date 类概述"></a><strong>Date</strong> <strong>类概述</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Date类代表当前所在系统的日期时间信息。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>          <span class="comment">//创建一个Date对象，代表的是系统当前此刻日期时间。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>    <span class="comment">//把时间毫秒值转换成Date日期对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span><span class="comment">//返回从1970年1月1日    00:00:00走到此刻的总的毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>  <span class="comment">//设置日期对象的时间为当前时间毫秒值对应的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a><strong>SimpleDateFormat</strong>类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*代表简单日期格式化，可以用来把日期时间格式化成为我们想要的形式。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> SimpleDateFormat​(String pattern) <span class="comment">//创建简单日期格式化对象，并封装格式化的形式信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span><span class="comment">//将日期格式化成日期/时间字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Object time)</span><span class="comment">//将时间毫秒值式化成日期/时间字符串</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span> <span class="comment">//  从给定字符串的开始解析文本以生成日期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Calendar代表了系统此刻日期对应的日历对象。</span></span><br><span class="line"><span class="comment">Calendar是一个抽象类，不能直接创建对象。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span><span class="comment">//获取当前日历对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>  <span class="comment">//取日期中的某个字段信息。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field,<span class="type">int</span> value)</span><span class="comment">//修改日历的某个字段信息。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field,<span class="type">int</span> amount)</span><span class="comment">//为某个字段增加/减少指定的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span><span class="comment">//拿到此刻日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span><span class="comment">//拿到此刻时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：calendar是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。*/</span></span><br></pre></td></tr></table></figure>

<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">/* 基本类型      包装类</span></span><br><span class="line"><span class="comment">          byte     Byte</span></span><br><span class="line"><span class="comment">          short    Short</span></span><br><span class="line"><span class="comment">          int       Integer</span></span><br><span class="line"><span class="comment">          long      Long</span></span><br><span class="line"><span class="comment">          float     Float</span></span><br><span class="line"><span class="comment">          double    Double</span></span><br><span class="line"><span class="comment">          char       Character</span></span><br><span class="line"><span class="comment">          boolean    Boolean */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实就是8种基本数据类型对应的引用类型。</span></span><br><span class="line"><span class="comment">Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型。</span></span><br><span class="line"><span class="comment">后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自动装箱：基本类型的数据和变量可以直接赋值给包装类型的变量。</span></span><br><span class="line"><span class="comment">自动拆箱：包装类型的变量可以直接赋值给基本数据类型的变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">包装类的特有功能</span></span><br><span class="line"><span class="comment">包装类的变量的默认值可以是null，容错率更高。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以把基本类型的数据转换成字符串类型(用处不大)</span></span><br><span class="line"><span class="comment">调用toString()方法得到字符串结果。</span></span><br><span class="line"><span class="comment">调用Integer.toString(基本类型的数据)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以把字符串类型的数值转换成真实的数据类型（真的很有用）</span></span><br><span class="line"><span class="comment">Integer.parseInt(“字符串类型的整数”)</span></span><br><span class="line"><span class="comment">Double.parseDouble(“字符串类型的小数”)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串对象提供了匹配正则表达式的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> matches​(String regex)        <span class="comment">//判断是否匹配正则表达式，匹配返回true，不匹配返回false。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符类(默认匹配一个字符)</span></span><br><span class="line"><span class="comment">[abc]	       只能是a, b, 或c</span></span><br><span class="line"><span class="comment">[^abc]	       除了a, b, c之外的任何字符</span></span><br><span class="line"><span class="comment">[a-zA-Z]               a到z A到Z，包括（范围）</span></span><br><span class="line"><span class="comment">[a-d[m-p]]	       a到d，或m通过p：（[a-dm-p]联合）</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[def]]	       d, e, 或f(交集)</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[^bc]]	       a到z，除了b和c：（[ad-z]减法）</span></span><br><span class="line"><span class="comment">[a-z&amp;&amp;[^m-p]]     a到z，除了m到p：（[a-lq-z]减法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">预定义的字符类(默认匹配一个字符)</span></span><br><span class="line"><span class="comment">.	任何字符</span></span><br><span class="line"><span class="comment">\d	一个数字： [0-9]</span></span><br><span class="line"><span class="comment">\D	非数字： [^0-9]</span></span><br><span class="line"><span class="comment">\s	一个空白字符： [ \t\n\x0B\f\r]</span></span><br><span class="line"><span class="comment">\S	非空白字符： [^\s]</span></span><br><span class="line"><span class="comment">\w	[a-zA-Z_0-9] 英文、数字、下划线</span></span><br><span class="line"><span class="comment">\W	 [^\w] 一个非单词字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">贪婪的量词（配合匹配多个字符）</span></span><br><span class="line"><span class="comment">X?	X , 一次或根本不</span></span><br><span class="line"><span class="comment">X*	X，零次或多次</span></span><br><span class="line"><span class="comment">X+	X , 一次或多次</span></span><br><span class="line"><span class="comment">X &#123;n&#125;	X，正好n次</span></span><br><span class="line"><span class="comment">X &#123;n, &#125;	X，至少n次</span></span><br><span class="line"><span class="comment">X &#123;n,m&#125;	X，至少n但不超过m次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;ab&quot;</span>.matches(<span class="string">&quot;[abc]+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组操作工具类，专门用于操作数组元素的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(类型[] a)</span>             <span class="comment">//返回数组的内容（字符串形式）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(类型[] a)</span>                   <span class="comment">//对数组进行默认升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(类型[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>    <span class="comment">//使用比较器对象自定义排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span>            <span class="comment">//二分搜索数组中的数据，存在返回索引，不存在返回-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="十八-集合"><a href="#十八-集合" class="headerlink" title="十八.集合"></a>十八.集合</h3><p>集合分为Collection单列和Map双列集合</p>
<p>Collection接口有两个继承接口,List和Set</p>
<p>List接口有两个实现类,**ArrayList、LinekdList **</p>
<p>Set接口有两个实现类,<strong>HashSet.TreeSet</strong>,HashSet有个继承类为LinkedHashSet</p>
<p>Collection集合特点:</p>
<p><strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。</p>
<p>ArrayList、LinekdList ：有序、可重复、有索引。</p>
<p><strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。</p>
<p>HashSet: 无序、不重复、无索引；LinkedHashSet: <strong>有序</strong>、不重复、无索引。</p>
<p>TreeSet：<strong>按照大小默认升序排序、</strong>不重复、无索引。</p>
<p><strong>注意：集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p>
<h4 id="Collection-API"><a href="#Collection-API" class="headerlink" title="Collection API"></a>Collection API</h4><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p>
<p><strong>Collection API如下:</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  boolean add(E e)</td>
<td>把给定的对象添加到当前集合中</td>
</tr>
<tr>
<td>public  void clear()</td>
<td>清空集合中所有的元素</td>
</tr>
<tr>
<td>public  boolean remove(E e)</td>
<td>把给定的对象在当前集合中删除</td>
</tr>
<tr>
<td>public  boolean contains(Object obj)</td>
<td>判断当前集合中是否包含给定的对象</td>
</tr>
<tr>
<td>public  boolean isEmpty()</td>
<td>判断当前集合是否为空</td>
</tr>
<tr>
<td>public  int size()</td>
<td>返回集合中元素的个数。</td>
</tr>
<tr>
<td>public  Object[] toArray()</td>
<td>把集合中的元素，存储到数组中</td>
</tr>
</tbody></table>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="方式一：迭代器"><a href="#方式一：迭代器" class="headerlink" title="方式一：迭代器"></a>方式一：迭代器</h5><p>迭代器在Java中的代表是<strong>Iterator</strong>，迭代器是集合的专用的遍历方式。</p>
<p><strong>Collection****集合获取迭代器</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Iterator<E></strong>  <strong>iterator()</strong></td>
<td>返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td>
</tr>
</tbody></table>
<p><strong>Iterator****中的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>询问当前位置是否有元素存在，存在返回true ,不存在返回false</td>
</tr>
<tr>
<td>E  next()</td>
<td>获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="方式二：foreach-增强for循环"><a href="#方式二：foreach-增强for循环" class="headerlink" title="方式二：foreach/增强for循环"></a>方式二：foreach/增强for循环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(元素数据类型 变量名 : 数组或者Collection集合) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //在此处使用变量即可，该变量就是元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">既可以遍历集合也可以遍历数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String ele : list) &#123;</span><br><span class="line">        System.out.println(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="方式三：lambda表达式"><a href="#方式三：lambda表达式" class="headerlink" title="方式三：lambda表达式"></a>方式三：lambda表达式</h5><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p><strong>List系列集合特点</strong></p>
<p> ArrayList、LinekdList ：有序，可重复，有索引。</p>
<p>有序：存储和取出的元素顺序一致</p>
<p>有索引：可以通过索引操作元素</p>
<p>可重复：存储的元素可以重复</p>
<p><strong>List</strong> <strong>集合特有方法</strong></p>
<p>List集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int  index,E element)</td>
<td>在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td>E remove(int  index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>E set(int index,E  element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E get(int  index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody></table>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>ArrayList</strong> <strong>集合底层原理</strong></p>
<p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。</p>
<p>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。</p>
<p>当长度超过当前数组长时,创建一个更大的数组,并对老数组进行迁移</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>LinkedList</strong> <strong>的特点</strong></p>
<p>l底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</p>
<p><strong>LinkedList</strong> <strong>集合的特有功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void addFirst(E e)</td>
<td>在该列表开头插入指定的元素</td>
</tr>
<tr>
<td>public  void addLast(E e)</td>
<td>将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td>public  E getFirst()</td>
<td>返回此列表中的第一个元素</td>
</tr>
<tr>
<td>public  E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>public  E removeFirst()</td>
<td>从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td>public  E removeLast()</td>
<td>从此列表中删除并返回最后一个元素</td>
</tr>
</tbody></table>
<p>当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。</p>
<p>删除当前元素,指针后移会导致跳过删除元素后一个元素.</p>
<p>迭代器遍历集合且直接用集合删除元素的时候可能出现。</p>
<p>迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</p>
<p>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</p>
<p>使用for循环遍历并删除元素不会存在这个问题。</p>
<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</p>
<p>泛型的格式：&lt;数据类型&gt;; 注意：泛型只能支持引用数据类型。</p>
<p>集合体系的全部接口和实现类都是支持泛型的使用的。</p>
<p><strong>泛型的好处：</strong></p>
<p>统一数据类型。</p>
<p>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</p>
<p>泛型有:泛型类,泛型方法,泛型接口</p>
<p>泛型类</p>
<p>定义类时同时定义了泛型的类就是泛型类。</p>
<p>泛型类的格式：修饰符 class 类名&lt;泛型变量&gt;{ }</p>
<p>泛型方法</p>
<p>定义方法时同时定义了泛型的方法就是泛型方法。</p>
<p>泛型方法的格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</p>
<p>泛型接口</p>
<p>使用了泛型定义的接口就是泛型接口。</p>
<p>泛型接口的格式：修饰符 interface 接口名称&lt;泛型变量&gt;{}</p>
<p>? 可以在“使用泛型”的时候代表一切类型。</p>
<p> E T K V 是在定义泛型的时候使用的。</p>
<p>通配符上下限:</p>
<p>? <strong>extends</strong> <strong>Car</strong>: ?必须是Car或者其子类  泛型上限</p>
<p> ? <strong>super</strong> <strong>Car</strong> ： ?必须是Car或者其父类  泛型下限</p>
<h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p><strong>Set</strong> <strong>系列集合特点</strong></p>
<p>无序：存取顺序不一致</p>
<p>不重复：可以去除重复</p>
<p>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素。</p>
<p><strong>Set</strong> <strong>集合</strong> <strong>实现类特点</strong></p>
<p> HashSet : 无序、不重复、无索引。</p>
<p>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</p>
<p>TreeSet：<strong>排序</strong>、不重复、无索引。</p>
<p><strong>Set</strong> <strong>集合的功能上基本上与</strong> <strong>Collection</strong> <strong>的</strong> <strong>API</strong> <strong>一致。</strong></p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h5><p><strong>HashSet</strong> <strong>底层原理</strong></p>
<p>HashSet集合底层采取<strong>哈希表</strong>存储的数据。</p>
<p>哈希表是一种对于增删改查数据性能都较好的结构。</p>
<p><strong>哈希表的组成</strong></p>
<p>JDK8之前的，底层使用<strong>数组</strong> <strong>+</strong> <strong>链表</strong>组成</p>
<p>JDK8开始后，底层采用<strong>数组</strong> <strong>+</strong> <strong>链表</strong> <strong>+</strong> <strong>红黑树</strong>组成。</p>
<p>在了解哈希表之前需要先理解哈希值的概念:是JDK根据对象的<strong>地址</strong> <strong>，</strong>按照某种规则算出来的int类型的<strong>数值。</strong></p>
<p><strong>Object</strong> <strong>类的</strong> <strong>API</strong></p>
<p>public int hashCode()：返回对象的哈希值</p>
<p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p>
<p>默认情况下，不同对象的哈希值是不同的。</p>
<p><strong>HashSet1.7</strong> <strong>版本原理解析：数组</strong> <strong>+</strong> <strong>链表</strong> <strong>+</strong> <strong>（结合哈希算法）</strong></p>
<p>①创建一个默认长度16的数组，数组名table</p>
<p>②根据元素的哈希值跟数组的长度求余计算出应存入的位置（哈希算法）</p>
<p>③判断当前位置是否为null，如果是null直接存入</p>
<p>④如果位置不为null，表示有元素，则调用equals方法比较</p>
<p>⑤如果一样，则不存，如果不一样，则存入数组，</p>
<p>JDK 7新元素占老元素位置，指向老元素</p>
<p>JDK 8中新元素挂在老元素下面</p>
<p><strong>JDK1.8</strong> <strong>版本开始</strong> <strong>HashSet</strong> <strong>原理解析</strong></p>
<p>底层结构：哈希表（数组、链表、红黑树的结合体）</p>
<p>当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过<strong>8</strong>的时候，自动转换为红黑树。</p>
<p><strong>HashSet</strong> <strong>去重复原理解析</strong></p>
<p> ①创建一个默认长度16的数组，数组名table</p>
<p>②根据元素的<strong>哈希值</strong>跟<strong>数组的长度求余</strong>计算出应存入的位置<strong>（哈希算法）</strong></p>
<p>③判断当前位置是否为null，如果是null直接存入</p>
<p>④<strong>如果位置不为</strong> <strong>null</strong> <strong>，表示有元素，则调用</strong> <strong>equals</strong> <strong>方法比较</strong></p>
<p>⑤<strong>如果一样，则不存，如果不一样，则存入数组，</strong></p>
<p><strong>结论：如果希望</strong> <strong>Set</strong> <strong>集合认为</strong> <strong>2</strong> <strong>个内容一样的对象是重复的，</strong></p>
<p><strong>必须重写对象的</strong> <strong>hashCode</strong> <strong>()</strong> <strong>和</strong> <strong>equals()</strong> <strong>方法</strong></p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p><strong>LinkedHashSet</strong> <strong>集合概述和特点</strong></p>
<p><strong>有序</strong>、不重复、无索引。</p>
<p>这里的有序指的是保证存储和取出的元素顺序一致</p>
<p><strong>原理</strong>：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p><strong>TreeSet</strong> <strong>集合概述和特点</strong></p>
<p>不重复、无索引、可排序</p>
<p>可排序：按照元素的大小默认升序（有小到大）排序。</p>
<p>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</p>
<p><strong>注意：</strong> <strong>TreeSet</strong> <strong>集合是一定要排序的，可以将元素按照指定的规则进行排序。</strong></p>
<p>对于数值类型：Integer , Double，官方默认按照大小进行升序排序。</p>
<p>对于字符串类型：默认按照首字符的编号升序排序。</p>
<p>对于自定义类型如Student对象，TreeSet无法直接排序。</p>
<p><strong>结论：想要使用</strong> <strong>TreeSet</strong> <strong>存储自定义类型，需要制定排序规则</strong></p>
<p><strong>自定义排序规则</strong></p>
<p>lTreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则</p>
<p><strong>方式一</strong></p>
<p>让自定义的类（如学生类）<strong>实现</strong> <strong>Comparable</strong> <strong>接口</strong>重写里面的<strong>compareTo</strong>方法<strong>来定制比较规则。</strong></p>
<p><strong>方式二</strong>(优先级高)</p>
<p><strong>TreeSet</strong> <strong>集合有参数构造器，可以设置</strong> <strong>Comparator</strong> <strong>接口对应的比较器对象，来定制比较规则。</strong></p>
<p><strong>两种方式中，关于返回值的规则：</strong></p>
<p>l如果认为第一个元素大于第二个元素返回正整数即可。</p>
<p>l如果认为第一个元素小于第二个元素返回负整数即可。</p>
<p>l如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素，认为两者重复。</p>
<p><strong>注意：如果</strong> <strong>TreeSet</strong> <strong>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</strong></p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据。</p>
<p>可变参数的格式：数据类型…参数名称</p>
<p>接收参数非常灵活，方便。可以不接收参数，可以接收1个或者多个参数，也可以接收一个数组</p>
<p><strong>可变参数在方法内部本质上就是一个数组。</strong></p>
<p>1.一个形参列表中可变参数只能有一个</p>
<p>2.可变参数必须放在形参列表的最后面</p>
<h4 id="Collections-集合工具类"><a href="#Collections-集合工具类" class="headerlink" title="Collections 集合工具类"></a><strong>Collections</strong> <strong>集合工具类</strong></h4><p>java.utils.Collections:是集合工具类</p>
<p>作用：Collections并不属于集合，是用来操作集合的工具类。</p>
<p><strong>Collections常用的API</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> boolean  addAll(Collection&lt;? super T&gt; c, T… elements)</td>
<td>给集合对象批量添加元素</td>
</tr>
<tr>
<td>public static void shuffle(List&lt;?&gt; list)</td>
<td>打乱List集合元素的顺序</td>
</tr>
</tbody></table>
<p><strong>Collections</strong> <strong>排序相关</strong> <strong>API</strong></p>
<p>使用范围：只能对于List集合的排序。</p>
<p><strong>排序方式</strong> <strong>1</strong> <strong>：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list)</td>
<td>将集合中元素按照默认规则排序</td>
</tr>
</tbody></table>
<p>注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</p>
<p><strong>排序方式</strong> <strong>2</strong> <strong>：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; c)</td>
<td>将集合中元素按照指定规则排序</td>
</tr>
</tbody></table>
<h4 id="MAP集合"><a href="#MAP集合" class="headerlink" title="MAP集合"></a>MAP集合</h4><p><strong>Map</strong> <strong>集合概述和使用</strong></p>
<p>Map集合是一种双列集合，每个元素包含两个数据。</p>
<p>Map集合的每个元素的格式：key=value(键值对元素)。</p>
<p>Map集合也被称为“<strong>键值对集合</strong>”。</p>
<p><strong>Map</strong> <strong>集合整体格式：</strong></p>
<p>Collection集合的格式: [元素1,元素2,元素3..]</p>
<p>Map集合的完整格式：{key1=value1 , key2=value2 , key3=value3 , …}</p>
<p><img src="D:\myblog\source_posts\Linux\Snipaste_2022-11-04_18-56-31.png"></p>
<p><strong>使用最多的</strong> <strong>Map</strong> <strong>集合是</strong> <strong>HashMap</strong> <strong>。</strong></p>
<p>重点掌握HashMap , LinkedHashMap , TreeMap。其他的后续理解。</p>
<p><strong>Map</strong> <strong>集合的键</strong> <strong>无序、不重复的</strong></p>
<p><strong>Map</strong> <strong>集合的值</strong> <strong>值不做要求</strong> <strong>可以重复</strong></p>
<p><strong>Map集合体系特点</strong></p>
<p>Map集合的特点都是由键决定的。</p>
<p>Map集合的键是无序,不重复的，无索引的，值不做要求（可以重复）。</p>
<p>Map集合后面重复的键对应的值会覆盖前面重复键的值。</p>
<p>Map集合的键值对都可以为null。</p>
<p><strong>Map集合实现类特点</strong></p>
<p>HashMap:元素按照键是无序，不重复，无索引，值不做要求。（与Map体系一致）</p>
<p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求。</p>
<p>TreeMap：元素按照建是<strong>排序</strong>，不重复，无索引的，值不做要求。</p>
<p><strong>Map集合</strong> </p>
<p>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map &lt;String,Integer&gt; maps =new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V  put(K key,V value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V  remove(Object key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>void  clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int  size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式有：3种。</strong></p>
<p>方式一：键找值的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</p>
<p>方式二：键值对的方式遍历，把“键值对“看成一个整体，难度较大。</p>
<p>方式三：JDK 1.8开始之后的新技术：Lambda表达式。</p>
<p><strong>Map集合的遍历方式一：键找值</strong></p>
<p>先获取Map集合的全部键的Set集合。</p>
<p>遍历键的Set集合，然后通过键提取对应值。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set<K>  keySet()</td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>V  get(Object key)</td>
<td>根据键获取值</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式二：键值对</strong></p>
<p>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</p>
<p>遍历Set集合，然后提取键以及提取值。</p>
<p><strong>键值对涉及到的API:</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
<tr>
<td>K getKey()</td>
<td>获得键</td>
</tr>
<tr>
<td>V getValue()</td>
<td>获取值</td>
</tr>
</tbody></table>
<p><strong>Map集合的遍历方式三Lambda</strong></p>
<p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(BiConsumer&lt;?  super  K,  ? super  V&gt;  action)</td>
<td>结合lambda遍历Map集合</td>
</tr>
</tbody></table>
<p><img src="D:\myblog\source_posts\Linux\Snipaste_2022-11-04_19-17-39.png"></p>
<h5 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a><strong>HashMap的特点</strong></h5><p>HashMap是Map里面的一个实现类。特点都是由键决定的：无序、不重复、无索引</p>
<p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</p>
<p>HashMap跟HashSet底层原理是一模一样的，都是哈希表结构，只是HashMap的每个元素包含两个值而已。</p>
<p><strong>实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</strong></p>
<p><strong>1.HashMap的特点和底层原理</strong></p>
<p>由键决定：无序、不重复、无索引。HashMap底层是哈希表结构的。</p>
<p>依赖hashCode方法和equals方法保证<strong>键</strong>的唯一。</p>
<p>如果<strong>键</strong>要存储的是自定义对象，需要重写hashCode和equals方法。</p>
<p>基于哈希表。增删改查的性能都较好。</p>
<h5 id="LinkedHashMap集合概述和特点"><a href="#LinkedHashMap集合概述和特点" class="headerlink" title="LinkedHashMap集合概述和特点"></a><strong>LinkedHashMap集合概述和特点</strong></h5><p><strong>由键决定：有序</strong>、不重复、无索引。</p>
<p>这里的有序指的是保证存储和取出的元素顺序一致</p>
<p><strong>原理</strong>：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p>
<h5 id="TreeMap集合概述和特点"><a href="#TreeMap集合概述和特点" class="headerlink" title="TreeMap集合概述和特点"></a><strong>TreeMap集合概述和特点</strong></h5><p>由键决定特性：不重复、无索引、可排序</p>
<p>可排序：按照键数据的大小默认升序（有小到大）排序。<strong>只能对键排序。</strong></p>
<p><strong>注意：TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</strong></p>
<p>TreeMap跟TreeSet一样底层原理是一样的。</p>
<p><strong>TreeMap集合自定义排序规则有2种</strong></p>
<p>类实现Comparable接口，重写比较规则。</p>
<p>集合自定义Comparator比较器对象，重写比较规则。</p>
<h5 id="Map集合实现类特点"><a href="#Map集合实现类特点" class="headerlink" title="Map集合实现类特点"></a><strong>Map集合实现类特点</strong></h5><p>HashMap:元素按照键是无序，不重复，无索引，值不做要求，基于哈希表（与Map体系一致）</p>
<p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求，基于哈希表</p>
<p>TreeMap：元素只能按照键<strong>排序</strong>，不重复，无索引的，值不做要求，可以做排序</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>git-命令</title>
    <url>/2022/08/15/git-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h3><p>touch 创建<br>git init 创建仓库<br>git status 查看状态<br>git add .  全部到缓存区<br>git commit -m “注释”<br>git log    查看仓库<br>git-log    间接查看<br>git reset –hard commitID  回退<br>git reflog     操作记录<br>git branch   查看分支<br>git branch 名字<br>git checkout 名字  切换分之<br>git checkout -b  创建并切换<br>git merge 名字   合并分之<br>git branch -d b1 检查删除<br>git branch -D b1 强制删除<br>ssh-keygen -t rsa   创建ssh<br>cat ～/.ssh/id_rsa.pub 查看ssh<br>ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x65;&#101;&#x2e;&#99;&#x6f;&#109;</a> 查看链接的ssh    <br>git remote add 仓库名字（origin） 地址   链接仓库    <br>git remote rm 仓库名称<br>git remote    查看链接的仓库<br>git push -f –set-upstream 远端仓库 本地分支名:远端分支名      可以简化后面三个        -f:强制推送  –set-upstream :链接远端分支<br>git branch -vv 查看链接的远端分支<br>git clone ssh地址 本地目录<br>git fetch 《remote name》 《branch name》<br>git pull 《remote name》 《branch name》</p>
<p>仓库地址 <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#101;&#x65;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#101;&#x65;&#46;&#99;&#111;&#x6d;</a>:yyl1546139844/yyl.git</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/11/03/Linux/</url>
    <content><![CDATA[<h3 id="一-Linux简介与安装"><a href="#一-Linux简介与安装" class="headerlink" title="一.Linux简介与安装"></a>一.Linux简介与安装</h3><h3 id="二-Linux基础命令"><a href="#二-Linux基础命令" class="headerlink" title="二.Linux基础命令"></a>二.Linux基础命令</h3><h4 id="1-Linux目录结构"><a href="#1-Linux目录结构" class="headerlink" title="1.Linux目录结构"></a>1.Linux目录结构</h4><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027214128.png" alt="image-20221027214128453"></p>
<ul>
<li><code>/</code>，根目录是最顶级的目录了</li>
<li>Linux只有一个顶级目录：<code>/</code></li>
<li>路径描述的层次关系同样适用<code>/</code>来表示</li>
<li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li>
</ul>
<h4 id="2-Linux命令基础"><a href="#2-Linux命令基础" class="headerlink" title="2.Linux命令基础"></a>2.Linux命令基础</h4><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式：</p>
<p>command [-options] [parameter]</p>
<p>•command： 命令本身</p>
<p>•-options：[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节</p>
<p>•parameter：[可选，非必填]命令的参数，多数用于命令的指向目标等</p>
<p>语法中的[]，表示可选的意思</p>
<p>功能：列出文件夹信息</p>
<h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>语法：<code>ls [-l -h -a] [参数]</code></p>
<ul>
<li><p>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</p>
</li>
<li><p>-l，以列表形式查看</p>
</li>
<li><p>-h，配合-l，以更加人性化的方式显示文件大小</p>
</li>
<li><p>-a，显示隐藏文件</p>
<p>隐藏文件、文件夹:</p>
<p>在Linux中以<code>.</code>开头的，均是隐藏的。</p>
<p>默认不显示出来，需要<code>-a</code>选项才可查看到</p>
</li>
</ul>
<p>直接输入ls命令，表示列出当前工作目录下的内容，当前工作目录是？</p>
<p>Linux系统的命令行终端，在启动的时候，默认会加载:</p>
<p>•当前登录用户的HOME目录作为当前工作目录，所以ls命令列出的是HOME目录的内容</p>
<p>•HOME目录：每个Linux操作用户在Linux系统的个人账户目录，路径在：/home/用户名</p>
<p>语法中的选项是可以组合使用的，比如学习的-a和-l可以组合应用。</p>
<p>写法：</p>
<p>•ls -l -a</p>
<p>•ls -la</p>
<p>•ls -al</p>
<p>上述三种写法，都是一样的，表示同时应用-l和-a的功能</p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>Change Directory</p>
<p>功能：切换工作目录</p>
<p>语法：<code>cd [目标目录]</code></p>
<p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p>
<h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>Print Work Directory</p>
<p>功能：展示当前工作目录</p>
<p>语法：<code>pwd</code></p>
<ol>
<li>相对路径和绝对路径</li>
</ol>
<p>•绝对路径：以根目录做起点，描述路径的方式，路径以/开头</p>
<p>•相对路径：以当前目录做起点，描述路径的方式，路径不需以/开头</p>
<p>•如无特殊需求，后续学习中，将经常使用相对路径表示</p>
<ol start="2">
<li>特殊路径符</li>
</ol>
<ul>
<li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li>
<li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li>
<li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li>
<li></li>
</ul>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>功能：创建文件夹</p>
<p>语法：<code>mkdir [-p] 参数</code></p>
<ul>
<li>参数：被创建文件夹的路径</li>
<li>选项：-p，可选，表示创建前置路径</li>
</ul>
<p><strong>注意：创建文件夹需要修改权限</strong></p>
<h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>功能：创建文件</p>
<p>语法：<code>touch 参数</code></p>
<ul>
<li>参数：被创建的文件路径</li>
</ul>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>功能：查看文件内容</p>
<p>语法：<code>cat 参数</code></p>
<ul>
<li>参数：被查看的文件路径</li>
</ul>
<h5 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h5><p>功能：查看文件，可以支持翻页查看</p>
<p>语法：<code>more 参数</code></p>
<ul>
<li><p>参数：被查看的文件路径</p>
</li>
<li><p>在查看过程中：</p>
<ul>
<li><p><code>空格</code>键翻页</p>
</li>
<li><p><code>q</code>退出查看</p>
</li>
</ul>
</li>
</ul>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>copy</p>
<p>功能：复制文件、文件夹</p>
<p>语法：<code>cp [-r] 参数1 参数2</code></p>
<ul>
<li><p>参数1，被复制的</p>
</li>
<li><p>参数2，要复制去的地方</p>
</li>
<li><p>选项：-r，可选，复制文件夹使用</p>
<p>复制文件夹，必须使用-r选项，否则不会生效</p>
</li>
</ul>
<p>示例：</p>
<ul>
<li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li>
<li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li>
<li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li>
</ul>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>move</p>
<p>功能：移动文件、文件夹</p>
<p>语法：<code>mv 参数1 参数2</code></p>
<ul>
<li>参数1：被移动的</li>
<li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li>
</ul>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>remove</p>
<p>功能：删除文件、文件夹</p>
<p>语法：<code>rm [-r -f] 参数...参数</code></p>
<ul>
<li>参数：支持多个，每一个表示被删除的，空格进行分隔</li>
<li>选项：-r，删除文件夹使用</li>
<li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li>
</ul>
<p>rm命令支持通配符 *，用来做模糊匹配</p>
<p>•符号* 表示通配符，即匹配任意内容（包含空），示例：</p>
<p>•test*，表示匹配任何以test开头的内容</p>
<p>•*test，表示匹配任何以test结尾的内容</p>
<p>•<em>test</em>，表示匹配任何包含test的内容</p>
<blockquote>
<p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p>
</blockquote>
<h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><p>我们在前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序。</p>
<p>和Windows系统中的.exe文件，是一个意思。</p>
<p>功能：查看命令的程序本体文件路径</p>
<p>语法：<code>which 参数</code></p>
<ul>
<li>参数：被查看的命令</li>
</ul>
<h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h5><p>功能：搜索文件</p>
<p>语法1按文件名搜索：<code>find 路径 -name &quot;参数&quot;</code></p>
<ul>
<li>路径，搜索的起始路径</li>
<li>参数，搜索的关键字，支持通配符*， 比如：<code>*</code>test表示搜索任意以test结尾的文件</li>
</ul>
<p>语法2：<code>find 路径 -size +|-n[KMG]</code></p>
<p>•+、- 表示大于和小于</p>
<p>•n表示大小数字</p>
<p>•kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</p>
<p>示例：</p>
<p>•查找小于10KB的文件： find / -size -10k</p>
<p>•查找大于100MB的文件：find / -size +100M</p>
<p>•查找大于1GB的文件：find / -size +1G</p>
<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>功能：过滤关键字</p>
<p>语法：<code>grep [-n] 关键字 文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<blockquote>
<p>参数文件路径，可以作为管道符的输入</p>
</blockquote>
<h5 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h5><p>功能：统计</p>
<p>语法：<code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<blockquote>
<p>参数文件路径，可作为管道符的输入</p>
</blockquote>
<h5 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h5><p>写法：<code>|</code></p>
<p>功能：将符号左边的结果，作为符号右边的输入</p>
<p>示例：</p>
<p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p>
<p>可以支持嵌套：</p>
<p><code>cat a.txt | grep itheima | grep itcast</code></p>
<h5 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h5><p>功能：输出内容</p>
<p>语法：<code>echo 参数</code></p>
<ul>
<li>参数：被输出的内容</li>
</ul>
<h5 id="反引号"><a href="#反引号" class="headerlink" title="`反引号"></a>`反引号</h5><p>功能：被两个反引号包围的内容，会作为命令执行</p>
<p>示例：</p>
<ul>
<li>echo `pwd`，会输出当前工作目录</li>
</ul>
<h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h5><p>功能：查看文件尾部内容</p>
<p>语法：<code>tail [-f -num] 参数</code></p>
<ul>
<li>参数：被查看的文件</li>
<li>选项：-f，持续跟踪文件修改</li>
<li>选项, -num，表示，查看尾部多少行，不填默认10行</li>
</ul>
<h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h5><p>功能：查看文件头部内容</p>
<p>语法：<code>head [-n] 参数</code></p>
<ul>
<li>参数：被查看的文件</li>
<li>选项：-n，查看的行数</li>
</ul>
<h5 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h5><p>功能：将符号左边的结果，输出到右边指定的文件中去</p>
<ul>
<li><code>&gt;</code>，表示覆盖输出</li>
<li><code>&gt;&gt;</code>，表示追加输出</li>
</ul>
<h5 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h5><p>vi\vim是visual interface的简称, 是Linux中最经典的文本编辑器</p>
<p>同图形化界面中的 文本编辑器一样，vi是命令行下对文本文件进行编辑的绝佳选择。</p>
<p>vim 是 vi 的加强版本，兼容 vi 的所有指令，不仅能编辑文本，而且还具有 shell 程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>
<p><strong>vi\vim编辑器的三种工作模式</strong></p>
<p><img src="D:\myblog\source_posts\Linux\Snipaste_2022-11-03_16-44-04.png"></p>
<p>命令模式（Command mode）</p>
<p> 命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。</p>
<p> 此模型下，不能自由进行文本编辑。</p>
<p>输入模式（Insert mode）</p>
<p> 也就是所谓的编辑模式、插入模式。</p>
<p> 此模式下，可以对文件内容进行自由编辑。</p>
<p>底线命令模式（Last line mode）</p>
<p> 以：开始，通常用于文件的保存、退出。</p>
<p>如果需要通过vi/vim编辑器编辑文件，请通过如下命令：</p>
<p>vi/vim 文件名称</p>
<p>vim兼容全部的vi功能，后续全部使用vim命令</p>
<p>•如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</p>
<p>•如果文件路径表示的文件存在，那么此命令用于编辑已有文件</p>
<p>命令模式快捷键</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png" alt="image-20221027215841573"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png" alt="image-20221027215846581"></p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png" alt="image-20221027215849668"></p>
<p>底线命令快捷键</p>
<p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png" alt="image-20221027215858967"></p>
<h4 id="命令的选项"><a href="#命令的选项" class="headerlink" title="命令的选项"></a>命令的选项</h4><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p>
<p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</p>
<h5 id="查看命令的帮助"><a href="#查看命令的帮助" class="headerlink" title="查看命令的帮助"></a>查看命令的帮助</h5><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p>
<h5 id="查看命令的详细手册"><a href="#查看命令的详细手册" class="headerlink" title="查看命令的详细手册"></a>查看命令的详细手册</h5><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p>
<h3 id="三-Linux用户和权限"><a href="#三-Linux用户和权限" class="headerlink" title="三.Linux用户和权限"></a>三.Linux用户和权限</h3><h4 id="1-root用户"><a href="#1-root用户" class="headerlink" title="1.root用户"></a>1.root用户</h4><p>无论是Windows、MacOS、Linux均采用多用户的管理模式进行权限管理。</p>
<p>•在Linux系统中，拥有最大权限的账户名为：root（超级管理员）</p>
<p>•而在前期，我们一直使用的账户是普通的用户</p>
<p>root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。</p>
<p>•普通用户的权限，一般在其HOME目录内是不受限的</p>
<p>•一旦出了HOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限</p>
<h5 id="su和sudo命令"><a href="#su和sudo命令" class="headerlink" title="su和sudo命令"></a>su和sudo命令</h5><p>在前面，我们接触过su命令切换到root账户。</p>
<p>su命令就是用于账户切换的系统命令，其来源英文单词：Switch User</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure>

<p>•- 符号是可选的，表示是否在切换用户后加载环境变量（后续讲解），建议带上</p>
<p>•参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root</p>
<p>•切换用户后，可以通过<code>exit</code>命令退回上一个用户，也可以使用快捷键：<code>ctrl + d</code></p>
<p>•使用普通用户，切换到其它用户需要输入密码，如切换到root用户</p>
<p>•使用root用户切换到其它用户，无需密码，可以直接切换</p>
<p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限。</p>
<p>但是我们不建议长期使用root用户，避免带来系统损坏。</p>
<p>我们可以使用sudo命令，为普通的命令授权，临时以root身份执行。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo 其他命令</span><br></pre></td></tr></table></figure>

<p>•在其它命令之前，带上<code>sudo</code>，即可为这一条命令临时赋予root授权</p>
<p>•但是并不是所有的用户，都有权利使用<code>sudo</code>，我们需要为普通用户配置sudo认证</p>
<p>•切换到root用户，执行<code>visudo</code>命令，会自动通过vi编辑器打开：<code>/etc/sudoers</code></p>
<p>•在文件的最后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名 ALL=(ALL)	NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<p>•其中最后的<code>NOPASSWD:ALL </code>表示使用<code>sudo</code>命令，无需输入密码</p>
<p>•最后通过 wq 保存</p>
<p>•切换回普通用户</p>
<p>•执行的<code>sudo</code>命令，均以root运行</p>
<h4 id="2-用户、用户组管理"><a href="#2-用户、用户组管理" class="headerlink" title="2.用户、用户组管理"></a>2.用户、用户组管理</h4><p>Linux系统中可以：</p>
<p>•配置多个用户</p>
<p>•配置多个用户组</p>
<p>•用户可以加入多个用户组中</p>
<p>Linux中关于权限的管控级别有2个级别，分别是：</p>
<p>•针对用户的权限控制</p>
<p>•针对用户组的权限控制</p>
<p>比如，针对某文件，可以控制用户的权限，也可以控制用户组的权限。</p>
<p>所以，我们需要学习在Linux中进行用户、用户组管理的基础命令，为后面学习权限控制打下基础。</p>
<p>以下命令需root用户执行</p>
<p>•创建用户组</p>
<p><code>groupadd 用户组名</code></p>
<p>•删除用户组</p>
<p><code>groupdel 用户组名</code></p>
<p>•创建用户</p>
<p><code>useradd [-g -d] 用户名</code></p>
<p>•选项：-g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p>
<p>•选项：-d指定用户HOME路径，不指定，HOME目录默认在：/home/用户名</p>
<p>•删除用户</p>
<p><code>userdel [-r] 用户名</code></p>
<p>•选项：-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</p>
<p>•查看用户所属组</p>
<p><code>id [用户名]</code></p>
<p>•参数：用户名，被查看的用户，如果不提供则查看自身</p>
<p>•修改用户所属组</p>
<p><code>usermod -aG 用户组 用户名</code>，将指定用户加入指定用户组</p>
<p>使用getent命令，可以查看当前系统中有哪些用户</p>
<p>语法： <code>getent passwd</code></p>
<p>共有7份信息，分别是：</p>
<p>用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</p>
<p>使用getent命令，同样可以查看当前系统中有哪些用户组</p>
<p>语法：getent group</p>
<p>包含3份信息，组名称:组认证(显示为x):组ID</p>
<h4 id="3-查看权限控制"><a href="#3-查看权限控制" class="headerlink" title="3.查看权限控制"></a>3.查看权限控制</h4><p>通过ls -l 可以以列表形式查看内容，并显示权限细节</p>
<p>•第1列，表示文件、文件夹的权限控制信息</p>
<p>•第2列，表示文件、文件夹所属用户</p>
<p>•第3列，表示文件、文件夹所属用户组</p>
<p>权限细节总共分为10个槽位</p>
<p>举例：drwxr-xr-x，表示：</p>
<p>•这是一个文件夹，首字母d表示</p>
<p>•所属用户(右上角图序号2)的权限是：有r有w有x，rwx</p>
<p>•所属用户组(右上角图序号3)的权限是：有r无w有x，r-x （-表示无此权限）</p>
<p>•其它用户的权限是：有r无w有x，r-x</p>
<p>d(文件夹) -(文件) l(软连接)</p>
<p>•r表示读权限</p>
<p>•w表示写权限</p>
<p>•x表示执行权限</p>
<p>针对文件、文件夹的不同，rwx的含义有细微差别</p>
<p>•r，针对文件可以查看文件内容</p>
<p>•针对文件夹，可以查看文件夹内容，如ls命令</p>
<p>•w，针对文件表示可以修改此文件</p>
<p>•针对文件夹，可以在文件夹内：创建、删除、改名等操作</p>
<p>•x，针对文件表示可以将文件作为程序执行</p>
<p>•针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</p>
<h4 id="4-修改权限控制-chmod"><a href="#4-修改权限控制-chmod" class="headerlink" title="4.修改权限控制 - chmod"></a>4.修改权限控制 - chmod</h4><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。</p>
<p>注意，只有文件、文件夹的所属用户或root用户可以修改。</p>
<p>语法：<code>chmod -R 文件或文件夹名称</code></p>
<p>•选项：-R，对文件夹内的全部内容应用同样的操作</p>
<p>示例：</p>
<p>•chmod u=rwx,g=rx,o=x hello.txt ，将文件权限修改为：rwxr-x–x</p>
<p>•其中：u表示user所属用户权限，g表示group组权限，o表示other其它用户权限</p>
<p>•chmod -R u=rwx,g=rx,o=x test，将文件夹test以及文件夹内全部内容权限设置为：rwxr-x–x</p>
<p>除此之外，还有快捷写法：chmod 751 hello.txt</p>
<p>将hello.txt的权限修改为751</p>
<p>权限可以用3位数字来代表，第一位数字表示用户权限，第二位表示用户组权限，第三位表示其它用户权限。</p>
<p>数字的细节如下：r记为4，w记为2，x记为1，可以有：</p>
<p>•0：无任何权限， 即 —</p>
<p>•1：仅有x权限， 即 –x</p>
<p>•2：仅有w权限 即 -w-</p>
<p>•3：有w和x权限 即 -wx</p>
<p>•4：仅有r权限 即 r–</p>
<p>•5：有r和x权限 即 r-x</p>
<p>•6：有r和w权限 即 rw-</p>
<p>•7：有全部权限 即 rwx</p>
<p>所以751表示： rwx(7) r-x(5) –x(1)</p>
<h4 id="5-修改所属用户和用户组-chown"><a href="#5-修改所属用户和用户组-chown" class="headerlink" title="5.修改所属用户和用户组 - chown"></a>5.修改所属用户和用户组 - chown</h4><p>使用chown命令，可以修改文件、文件夹的所属用户和用户组</p>
<p>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行</p>
<p>语法：        <code>chown -R [用户]:[用户组] 文件或文件夹名称</code></p>
<p>•选项，-R，同chmod，对文件夹内全部内容应用相同规则</p>
<p>•选项，用户，修改所属用户</p>
<p>•选项，用户组，修改所属用户组</p>
<p>•:用于分隔用户和用户组</p>
<p>示例：</p>
<p>•chown root hello.txt，将hello.txt所属用户修改为root</p>
<p>•chown :root hello.txt，将hello.txt所属用户组修改为root</p>
<p>•chown root:itheima hello.txt，将hello.txt所属用户修改为root，用户组修改为itheima</p>
<p>•chown -R root test，将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</p>
<h3 id="四-Linux常用操作"><a href="#四-Linux常用操作" class="headerlink" title="四.Linux常用操作"></a>四.Linux常用操作</h3><h4 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1.快捷键"></a>1.快捷键</h4><p><code>ctrl c</code>    退出</p>
<p><code>ctrl d </code>    登出</p>
<p><code>history </code>   查看历史命令</p>
<p><code>! 命令前缀 </code>    快速匹配执行过的命令</p>
<p><code>ctrl r</code>    搜索历史命令</p>
<p><code>ctrl a\e</code>    光标移动到最左端</p>
<p><code>ctrl ←\→</code>    光标跳跃单词移动</p>
<p><code>ctrl l </code>==<code>clear</code>    清屏</p>
]]></content>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2022/10/18/JDBC/</url>
    <content><![CDATA[<h3 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h3><p>概念：JDBC(Java DataBase Connectivity) ：Java数据库连接技术：具体讲就是通过Java连接广泛的数据库，并对表中数据执行增、删、改、查等操作的技术。</p>
<p>JDBC是数据库与JAVA代码的桥梁.</p>
<h3 id="JDBC相关接口"><a href="#JDBC相关接口" class="headerlink" title="JDBC相关接口"></a>JDBC相关接口</h3><table>
<thead>
<tr>
<th>接口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Driver</td>
<td>驱动接口，定义建立链接的方式</td>
</tr>
<tr>
<td>DriverManager</td>
<td>工具类，用于管理驱动，可以获取数据库的链接</td>
</tr>
<tr>
<td>Connection</td>
<td>表示Java与数据库建立的连接对象（接口）</td>
</tr>
<tr>
<td>PreparedStatement</td>
<td>发送SQL语句的工具</td>
</tr>
<tr>
<td>ResultSet</td>
<td>结果集，用于获取查询语句的结果</td>
</tr>
</tbody></table>
<p>JDBC是规范（接口）不是实现（类）<br>JDBC 是一种规范，由Sum公司它提供了一套完整的接口，由数据库厂商根据特点予以实现，因此只要学会接口的使用就可以轻松的用 JDBC编写适用于各种数据库的程序.</p>
<p>Mysql提供的JDBC实现<br>Mysql提供的JDBC实现称为<a href="https://dev.mysql.com/downloads/connector/j/">Mysql Connector</a>,不同的数据库版本需要使用不同的Connector。<br>实际开发时根据数据库版本、JDK版本、选择不同的Connector。</p>
<table>
<thead>
<tr>
<th>Connector版本</th>
<th>MySQL版本</th>
<th>JDK版本</th>
</tr>
</thead>
<tbody><tr>
<td>8.0</td>
<td>5.5,5.7,8.0</td>
<td>JDK8.0以上</td>
</tr>
<tr>
<td>5.1</td>
<td>5.6,5.7,8.0</td>
<td>JDK5.0以上</td>
</tr>
</tbody></table>
<h3 id="JDBC环境搭建"><a href="#JDBC环境搭建" class="headerlink" title="JDBC环境搭建"></a>JDBC环境搭建</h3><p>在项目中引入数据库驱动jar包（jar文件：针对class文件的压缩格式包含了多个带包的class文件，类似于普通文件打包的zip、rar）。</p>
<p>以idea为例:</p>
<p>将mysql-connector-java.jar添加到项目环境中。 1. 右键选中项目，新建一个Directory名为lib，将jar包复制到lib文件夹中。 2. 右键选中jar包，Add as Library –&gt; OK。</p>
<h3 id="JDBC的编程步骤"><a href="#JDBC的编程步骤" class="headerlink" title="JDBC的编程步骤"></a>JDBC的编程步骤</h3><ol>
<li><p>加载驱动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>获取链接 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;jdbc:mysql://127.0.0.1:3306/website&quot;</span>;</span><br><span class="line">String username=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;1546139844&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure></li>
<li><p>准备SQL以及发送SQL的工具 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into website(name, domain, id,tags) VALUES\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;(&#x27;test&#x27;,&#x27;test&#x27;,29,5);&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>执行SQL </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cont</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure></li>
<li><p>处理结果集 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cont);</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>释放资源</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>

<h3 id="JDBC-API-详解"><a href="#JDBC-API-详解" class="headerlink" title="JDBC API 详解"></a>JDBC API 详解</h3><h4 id="1-DriverManger"><a href="#1-DriverManger" class="headerlink" title="1.DriverManger"></a>1.DriverManger</h4><p>(1)注册驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>

<p>Driver类源代码中有静态代码实现注册驱动</p>
<p>Mysql5.0后可以自动加载META-INF/services/java.sql.Driver中的驱动类以省略该行代码</p>
<p>(2)获取链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static Connection getConnection(url,username,password);</span><br></pre></td></tr></table></figure>

<p>url:连接路径</p>
<p>jdbc:mysql://ip地址:端口号/数据库名称?参数键值对1&amp;参数键值对2…;</p>
<p>如果是本机3306端口号则可以简写jdbc:mysql:///数据库名称?</p>
<p>useSSL=false  禁用安全连接方式,解决警告提示</p>
<p>username:用户名</p>
<p>password:密码</p>
<h4 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2.Connection"></a>2.Connection</h4><p>获取执行SQL的对象</p>
<p>Statement createStatement()        普通执行SQL对象</p>
<p>PreparedStatement preparedStatement() 预编译执行,防止SQL注入</p>
<p>CallableStatement prapareCall(sql)   执行存储过程的对象</p>
<p>事务管理</p>
<p>setAutoCommit(boolean autoCommit);  设置自动提交事务</p>
<p>commit();        提交事务</p>
<p>rollback();        回滚</p>
<h4 id="3-Statment"><a href="#3-Statment" class="headerlink" title="3.Statment"></a>3.Statment</h4><p>执行sql语句</p>
<p>int executeUpdate(sql):DML DDL 语句   返回影响行数  DDL可能为零</p>
<p>ResultSet esecuteQuery(sql):DQL语句    返回ResultSet 结果集对象</p>
<h4 id="4-ResultSet"><a href="#4-ResultSet" class="headerlink" title="4.ResultSet"></a>4.ResultSet</h4><p>ResultSet（结果集对象）作用：<br>1.封装了DQL查询语句的结果<br>ResultSet stmt.executeQuery（sql）：执行DQL语句，返回ResultSet对象<br>获取查询结果<br>boolean next(）：（1）将光标从当前位置向前移动一行（2）判断当前行是否为有效行<br>返回值：<br>true：有效行，当前行有数据<br>false：无效行，当前行没有数据<br>XXX getXxx（参数）：获取数据<br>xxx：数据类型；如：int getint（参数）；String getString（参数）<br>参数：<br>int：列的编号，从1开始<br>String：列的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (rs.next)</span><br><span class="line">&#123;</span><br><span class="line">int n =getInt(1)          第一列</span><br><span class="line">String name =getInt(2)    第二列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-PreparedStatement"><a href="#5-PreparedStatement" class="headerlink" title="5.PreparedStatement"></a>5.PreparedStatement</h4><p>预编译执行,防止SQL注入</p>
<p>预编译SQL并执行SQL语句<br>1 获取PreparedStatement对象<br>//SQL语句中的参数值，使用？占位符替代<br>String sql = “select * from user where username = ? and password = ？”<br>//通过Connection对象获取，并传入对应的sql语句<br>PreparedStatement pstmt = conn.prepareStatement(sql）；<br>2 设置参数值<br>PreparedStatement对象：setXxx（参数1，参数2）：给？赋值<br>Xxx：数据类型；如setlnt（参数1，参数2）<br>参数：<br>参数1：？的位置编号，从1开始<br>参数2：？的值<br>3 执行SQL<br>executeUpdate(）；/executeQuery（）；：不需要再传递sql</p>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)<br>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个：<br>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏<br>好处：<br>资源重用<br>提升系统响应速度<br>·避免数据库连接遗漏</p>
<p>//1.导入jar包</p>
<p>DBCP   C3P0   Druid</p>
<p>//2.定义配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driverCassName=com.mysql.jdbc.Driver</span><br><span class="line">Url=jdbc:mysql:///db1？usesSL=false&amp;useServerPrepStmts=true</span><br><span class="line">username=root</span><br><span class="line">password=1234</span><br><span class="line">#初始化连接数量</span><br><span class="line">iitialsize=5</span><br><span class="line"># 最大连接数</span><br><span class="line">maxActive=10</span><br><span class="line">#最大等待时间</span><br><span class="line">maxWait=3000</span><br></pre></td></tr></table></figure>

<p>1/3.加载配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties prop=new PropertiesO；</span><br><span class="line">prop.load(new FileInputstream( name: &quot;src/druid·properties”）);</span><br></pre></td></tr></table></figure>


<p>//4获取连按池对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource（prop）；</span><br></pre></td></tr></table></figure>


<p>//5.获取数据库连接Connection</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection connection = dataSource.getconnection()；</span><br><span class="line">System.out.printin(connection）；</span><br></pre></td></tr></table></figure>

<h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<p>简单来说简化jdbc开发步骤</p>
<h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-20_20-02-10.png"></p>
<h5 id="1-创建user表-添加数据"><a href="#1-创建user表-添加数据" class="headerlink" title="1.创建user表,添加数据"></a>1.创建user表,添加数据</h5><p>在数据库中创建相应的表,添加数据</p>
<h5 id="2-创建模块-导入坐标"><a href="#2-创建模块-导入坐标" class="headerlink" title="2.创建模块,导入坐标"></a>2.创建模块,导入坐标</h5><p>在idea中创建模块</p>
<p><a href="https://mybatis.net.cn/">mybatis官网</a>有maven导入坐标的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;                           mybatis</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;x.x.x&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;                          junit自动化测试框架</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.13&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">···&lt;--·添加s1f4j日志api·--&gt;              springboot logback日志   还需要配置文件</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">···&lt;groupId&gt;org.s1f4j&lt;/groupId&gt;</span><br><span class="line">.&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">··&lt;version&gt;1.7.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-·添加1 ogback-c1 assic依赖·--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">··&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">...&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">.&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-·添加1 ogback-core依赖·-&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">··&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">.&lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">..&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-核心配置文件-mybatis-config-xml"><a href="#3-核心配置文件-mybatis-config-xml" class="headerlink" title="3.核心配置文件 mybatis-config.xml"></a>3.核心配置文件 mybatis-config.xml</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;environments default=&quot;development&quot;&gt;   通过default切换环境</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">      //配置信息</span><br><span class="line">        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;  </span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/库名称?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">      &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">  &lt;/environments&gt;</span><br><span class="line">  &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;    sql映射文件的路径</span><br><span class="line">  &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-sql映射文件-Mapper-xml"><a href="#4-sql映射文件-Mapper-xml" class="headerlink" title="4.sql映射文件 Mapper.xml"></a>4.sql映射文件 Mapper.xml</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">&lt;mapper namespace=&quot;namespace&quot;&gt;     名称空间名字</span><br><span class="line">  &lt;select id=&quot;selectid&quot; resultType=&quot;Blog&quot;&gt;  //id是唯一标识   Blog是返回的类型(pojo类名)</span><br><span class="line">    select * from Blog where id = #&#123;id&#125;  </span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>


<h5 id="5-编码"><a href="#5-编码" class="headerlink" title="5.编码"></a>5.编码</h5><p>(1)定义pojo类名</p>
<p>(2)加载核心配置文件,获取sqlsessionfactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;   //配置文件路径</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource); //</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>(3)获取sqlsession对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession =sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>(4)执行sql语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list&lt;user&gt; users = sqlSession.selectList(namespace.selectid)</span><br></pre></td></tr></table></figure>

<p>(5)释放资源</p>
<p>sqlSession.close();</p>
<p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-20_20-52-46.png"></p>
<h4 id="mapper代理"><a href="#mapper代理" class="headerlink" title="mapper代理"></a>mapper代理</h4><h5 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h5><p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-20_21-06-02.png"></p>
<h5 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1.定义接口"></a>1.定义接口</h5><p>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</p>
<p>在resources中新建directory 命名为将mapper接口的命名中的’.’改为’/‘</p>
<p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-20_21-16-10.png"></p>
<h5 id="2-设置namespace"><a href="#2-设置namespace" class="headerlink" title="2.设置namespace"></a>2.设置namespace<img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-20_21-25-02.png"></h5><p>设置SQL映射文件的namespace,属性为Mapper接口全限定名</p>
<p>以上图为例则为 com.itheima.mapper.UserMapper</p>
<h5 id="3-定义mapper方法"><a href="#3-定义mapper方法" class="headerlink" title="3.定义mapper方法"></a>3.定义mapper方法</h5><p>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id,并保持参数类型和返回值类型一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List &lt;pojo类名&gt; selectid();</span><br></pre></td></tr></table></figure>



<h5 id="4-编码"><a href="#4-编码" class="headerlink" title="4.编码"></a>4.编码</h5><p>1.通过SqlSession的getMapper方法获取Mapper接口的代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mapper接口 mapper=sqlSession.getMapper(mapper接口名.class);</span><br></pre></td></tr></table></figure>

<p>2.调用对应方法完成sq的执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List &lt;pojo类名&gt; users = mapper.方法名;</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在mybaties中有对配置的<a href="https://mybatis.net.cn/configuration.html">详细介绍</a></p>
<h4 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h4><h5 id="字段名对应实体属性"><a href="#字段名对应实体属性" class="headerlink" title="字段名对应实体属性"></a>字段名对应实体属性</h5><p>数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据<br>*起别名：对不一样的列名起别名，让别名和实体类的属性名一样<br>*缺点：每次查询都要定义一次别名<br>*sqL片段<br>*缺点：不灵活<br>resultMap:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义&lt;resultMap&gt;标签</span><br></pre></td></tr></table></figure>

<p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-20_21-47-38.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.在&lt;select&gt;标签中，使用resultMap属性替换resultType属性</span><br><span class="line">  &lt;select id=&quot;selectid&quot; resultMap=&quot;#id名&quot;&gt;  //id是唯一标识   Blog是返回的类型(pojo类名)</span><br><span class="line">    select * from Blog where id = #&#123;id&#125;  ;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>



<h5 id="参数占位符："><a href="#参数占位符：" class="headerlink" title="参数占位符："></a>参数占位符：</h5><p>1):执行SQL时，会将#{}占位符替换为？，将来自动设置参数值(在方法参数名前加上  @Param(“占位符”‘))<br>2)${}:拼SQL。会存在SQL注入问题<br>3.使用时机：<br>*参数传递，都使用#{}<br>*如果要对表名、列名进行动态设置，只能使用${}进行sql拼接。<br>2.parameterType:<br>*用于设置参数类型，该参数可以省略<br>3.SQL语句中特殊字符处理：<br>*转义字符<br>*&lt;[CDATA【内容】&gt;</p>
<h5 id="SQL语句设置多个参数三种方式"><a href="#SQL语句设置多个参数三种方式" class="headerlink" title="SQL语句设置多个参数三种方式"></a>SQL语句设置多个参数三种方式</h5><p>1)散装参数：需要使用@Param(“SQL中的参数占位符名称”)<br>2)实体类封装参数<br>*只需要保证SQL中的参数名和实体类属性名对应上，即可设置成功<br>3)map集合<br>*只需要保证SQL中的参数名和map集合的键的名称对应上，即可设置成功</p>
<h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>if:用于判断参数是否有值，使用test属性进行条件判断<br>*存在的问题：第一个条件不需要逻辑运算符<br>*解决方案：<br>1)使用恒等式让所有条件格式都一样<br>2)<where>标签替换where关键字</p>
<p>·从多个条件中选择一个      choose(when,otherwise):选择，类似于Java中的switch语句</p>
<h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;       inster标签  后面两个参数保证可以返回id</span><br><span class="line">    insert into website(name, domain,tags) VALUES</span><br><span class="line">(#&#123;name&#125;,#&#123;domain&#125;,#&#123;tags&#125;);</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;update&quot;&gt;</span><br><span class="line">    update website</span><br><span class="line">        &lt;set&gt;                              使用set标签防止格式错误</span><br><span class="line">        &lt;if test=&quot;domain!=null and domain!=&#x27;&#x27;&quot;&gt; domain=#&#123;domain&#125; ,&lt;/if&gt;       if条件判断</span><br><span class="line">        &lt;if test=&quot;name!=null and name!=&#x27;&#x27;&quot;&gt; name=#&#123;name&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;tags!=null&quot;&gt;           tags=#&#123;tags&#125;&lt;/if&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    where id=#&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>



<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-21_19-16-30.png"></p>
<h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p><img src="D:\myblog\source_posts\JDBC\Snipaste_2022-10-21_19-29-59.png"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2022/08/15/html/</url>
    <content><![CDATA[<h1 id="html-css"><a href="#html-css" class="headerlink" title="html/css"></a>html/css</h1><h2 id="一-文本属性"><a href="#一-文本属性" class="headerlink" title="一.文本属性"></a>一.文本属性</h2><p>文字整体为上边距，下边距和文本。</p>
<h2 id="二-元素显示模式"><a href="#二-元素显示模式" class="headerlink" title="二.元素显示模式"></a>二.元素显示模式</h2><h3 id="行内元素，块元素，行内块元素"><a href="#行内元素，块元素，行内块元素" class="headerlink" title="行内元素，块元素，行内块元素"></a>行内元素，块元素，行内块元素</h3><p>行内元素：<code>&lt;h1&gt;&lt;p&gt;&lt;div&gt;&lt;ul&gt;&lt;ol&gt;&lt;li&gt;</code></p>
<p>块元素:<code>&lt;a&gt;&lt;strong&gt;&lt;b&gt;&lt;em&gt;&lt;del&gt;&lt;s&gt;&lt;ins&gt;&lt;u&gt;&lt;span&gt;</code></p>
<p>行内块元素：<code>&lt;img/&gt;&lt;input/&gt;&lt;td&gt;</code></p>
<h2 id="三-盒子模型"><a href="#三-盒子模型" class="headerlink" title="三.盒子模型"></a>三.盒子模型</h2><p>外边距，边框，内边距</p>
<p><img src="https://tucang.cc/api/image/show/86de1bd5a56c77dace13eac588be9365"></p>
<h2 id="四-布局方式"><a href="#四-布局方式" class="headerlink" title="四.布局方式"></a>四.布局方式</h2><p>普通流，浮动，定位</p>
<h3 id="1-普通流"><a href="#1-普通流" class="headerlink" title="1.普通流"></a>1.普通流</h3><h3 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2.浮动"></a>2.浮动</h3><p>特性：脱标，一行显示，行内块元素特性，搭配标准流的父元素。</p>
<p> 浮动的元素会压住后面的标准流，但不会影响前面的标准流。</p>
<p> 清除浮动：<code>clear：both</code>  可以让父元素检测到高度</p>
<p>1.额外标签法：在最后一个浮动元素后加<code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></p>
<p>2.父元素添加<code>overflow：</code></p>
<p>3.after伪元素</p>
<p>4.双伪元素</p>
<h3 id="3-定位"><a href="#3-定位" class="headerlink" title="3.定位"></a>3.定位</h3><h4 id="1-定位模式"><a href="#1-定位模式" class="headerlink" title="1.定位模式"></a>1.定位模式</h4><p><img src="https://tucang.cc/api/image/show/75cd9b392b93190f65992c0c996590d3"></p>
<p><img src="https://tucang.cc/api/image/show/75cd9b392b93190f65992c0c996590d3"></p>
<h5 id="1-静态定位"><a href="#1-静态定位" class="headerlink" title="1.静态定位"></a>1.静态定位</h5><p><img src="https://tucang.cc/api/image/show/a83ace0e7e56e70530011ccff064f59f"></p>
<h5 id="2-相对定位"><a href="#2-相对定位" class="headerlink" title="2.相对定位"></a>2.相对定位</h5><p><img src="https://tucang.cc/api/image/show/f6fde91a3fab2fd7357a9186564dda5b"></p>
<h5 id="3-绝对定位"><a href="#3-绝对定位" class="headerlink" title="3.绝对定位"></a>3.绝对定位</h5><p><img src="https://tucang.cc/api/image/show/c6e5652f4a341ac8699f36f3105bebde"></p>
<h5 id="4-子绝父相"><a href="#4-子绝父相" class="headerlink" title="4.子绝父相"></a>4.子绝父相</h5><p><img src="https://tucang.cc/api/image/show/1d35f4aead1f802690804729057f8c02"></p>
<h5 id="5-固定定位"><a href="#5-固定定位" class="headerlink" title="5.固定定位"></a>5.固定定位</h5><p><img src="https://tucang.cc/api/image/show/ff98a8fbd70d16d3344579865c44e403"></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="D:\myblog\source_posts\html\Snipaste_2022-10-21_19-58-34.png"></p>
]]></content>
      <categories>
        <category>html</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java-web</title>
    <url>/2022/10/22/java-web/</url>
    <content><![CDATA[<h3 id="一-javaweb"><a href="#一-javaweb" class="headerlink" title="一.javaweb"></a>一.javaweb</h3><h4 id="1-什么是JavaWeb"><a href="#1-什么是JavaWeb" class="headerlink" title="1.什么是JavaWeb?"></a>1.什么是JavaWeb?</h4><p>Web:全球广域网，也称为万维网(www),能够通过刘览器访问的网站<br>JavaWeb:是用Java技术来解决相关web互联网领域的技术栈</p>
<h4 id="2-JavaWeb技术栈"><a href="#2-JavaWeb技术栈" class="headerlink" title="2.JavaWeb技术栈"></a>2.JavaWeb技术栈</h4><p>B/S架构：Browser/Server,浏览器/服务器架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数<br>据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可</p>
<p>好处：易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_18-03-19.png"></p>
<p>静态资源：HTML、CSS、JavaScript、图片等。负责页面展现<br>动态资源：Servlet、JSP等。负责逻辑处理<br>数据库：负责存储数据</p>
<p>HTTP协议：定义通信规则<br>Web服务器·负责解析HT工P协议解析请求数据并发送响应数据</p>
<h3 id="二-HTTP"><a href="#二-HTTP" class="headerlink" title="二.HTTP"></a>二.HTTP</h3><p>概念：HyperText Transfer Protocol,.超文本传输协议，规定了浏览器和服务器之间数据传输的规侧</p>
<h4 id="HTTP协议特点："><a href="#HTTP协议特点：" class="headerlink" title="HTTP协议特点："></a>HTTP协议特点：</h4><p>1.基于TCP协议：面向连接，安全<br>2..基于请求-响应模型的：一次请求对应一次响应<br>3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。<br>缺点：多次请求间不能共享数据。<br>优点：速度快</p>
<h4 id="HTTP请求数据格式"><a href="#HTTP请求数据格式" class="headerlink" title="HTTP请求数据格式"></a>HTTP请求数据格式</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_18-19-15.png"></p>
<p>请求数据分为3部分：<br>1.请求行：请求数据的第一行。其中GET表示请求方式，/<br>表示请求资源路径，HTTP/1.1表示协议版本<br>2.请求头：第二行开始，格式为key:value形式。<br>3.请求体：POST请求的最后一部分，存放请求参数</p>
<p>GET请求和POST请求区别：<br>1.GET请求请求参数在请求行中，没有请求体。<br>POST请求请求参数在请求体中<br>2.GET请求请求参数大小有限制，POST没有</p>
<p>常见的HTTP请求头：<br>Host:表示请求的主机名<br>User-Agent::浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0<br>Chrome/79,IE浏览器的标识类似Mozilla/5.0(Windows NT)like Gecko;<br>Accept:表示浏览器能接收的资源类型，如text/*,,image,/<em>或者</em>/*表示所有；<br>Accept–Language:表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；<br>Accept-.Encoding:表示浏览器可以支持的压缩类型，例如gzip,deflates等。</p>
<p>请求体</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_18-20-09.png"></p>
<h4 id="HTTP响应数据格式"><a href="#HTTP响应数据格式" class="headerlink" title="HTTP响应数据格式"></a>HTTP响应数据格式</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_18-23-02.png"></p>
<p>响应数据分为3部分：<br>1.响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示<a href="https://cloud.tencent.com/developer/chapter/13553">响应状态码</a>，OK表示状态码描述</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_18-24-08.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_18-28-42.png"></p>
<p>2.响应头：第二行开始，格式为key:value形式</p>
<p>常见的HTTP响应头：<br>Content–Type:表示该响应内容的类型，例如text/html,<br>image/jpeg;<br>Content-Length:表示该响应内容的长度（字节数）；<br>Content-Encoding:表示该响应压缩算法，例如gzip;<br>Cache-Control:指示客户端应如何缓存，例如max-age=300<br>表示可以最多缓存300秒</p>
<p>3.响应体：最后一部分。存放响应数据</p>
<h3 id="三-Tomcat"><a href="#三-Tomcat" class="headerlink" title="三.Tomcat"></a>三.Tomcat</h3><p>·概念：<a href="https://tomcat.apache.org/">Tomcat</a>是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP<br>少量JavaEE规范。<br>。JavaEE:Java Enterprise Edition,Java企业版。指）ava企业级开发的技术规范总和。包含l3项技术规范：JDBC<br>、JNDl、EJB、RMl、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、.JAF<br>Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖于Tomcat才能运行</p>
<h4 id="配置和部署项目"><a href="#配置和部署项目" class="headerlink" title="配置和部署项目"></a>配置和部署项目</h4><h5 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1.端口号"></a>1.端口号</h5><p>server.xml中的connector标签进行修改</p>
<h5 id="2-部署项目"><a href="#2-部署项目" class="headerlink" title="2.部署项目"></a>2.部署项目</h5><p>Tomcat部署项目：<br>将项目放置到webapps目录下，即部署完成<br>一般JavaWeb2项目会被打成war包，然后将war包放到webapps目<br>录下，Tomcat会自动解压缩war文件</p>
<h5 id="2-Tomcat-web项目结构"><a href="#2-Tomcat-web项目结构" class="headerlink" title="2.Tomcat-web项目结构"></a>2.Tomcat-web项目结构</h5><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_20-26-32.png"></p>
<p>点击项目＋f4打开项目设置</p>
<p>点击facets选择该项目点击右侧两个加号可以直接生成web相关文件夹</p>
<h5 id="3-idea集成本地tomcat"><a href="#3-idea集成本地tomcat" class="headerlink" title="3.idea集成本地tomcat"></a>3.idea集成本地tomcat</h5><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_20-47-16.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-00-44.png"></p>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-36-18.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-35-28.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-39-03.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-44-05.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-50-16.png" alt="Snipaste_2022-10-22_21-50-16"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-51-27.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-22_21-52-25.png"></p>
<p>当两个路径相同时优先访问优先级高的</p>
<p>DefaultServlet被覆盖掉后静态页面将会无法访问</p>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_18-35-02.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_19-36-13.png"></p>
<p>通过request对象的相关方法获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.setCharacterEncoding(&quot;UTF-8&quot;);           //改变字符输入流编码方式防止Post乱码</span><br><span class="line"></span><br><span class="line">byte[] bytes = name.getBytes(StandardCharsets.ISO_8859_1);  //解决GET请求方式乱码问题,将乱码通过ISO_8859_1编码成char数组,再通过UTF_8解码成汉字</span><br><span class="line">username = new String (bytes,StandarCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-02-57.png"></p>
<p>可以通过一些方法实现Get和Post同一方法获取参数</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_19-57-15.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-08-18.png"></p>
<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-23-22.png"></p>
<p>![(D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-24-24.png)</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-22-36.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-24-24.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-34-25.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-23_22-38-49.png"></p>
<h3 id="四-jsp"><a href="#四-jsp" class="headerlink" title="四.jsp"></a>四.jsp</h3><p>jsp(java Server Pages),java服务端页面</p>
<p>jsp=HTML+java</p>
<p>jsp可以简化开发,避免在servlet中直接输出HTML标签;</p>
<p>jsp原理就是由jsp容器(tomcat)将其转化为一个Servlet的java文件.html自动放入out.print()中</p>
<p>1.导入jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	javax.servlet.jsp</span><br><span class="line">	jsp-api</span><br><span class="line">	2.2</span><br><span class="line">	scope provided</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.jsp脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%...%&gt;   内容放到_jspService()方法中</span><br><span class="line">&lt;%=...%&gt;   内容放到out.print()方法中,相当于html</span><br><span class="line">&lt;%!...%&gt;   内容直接被类包含</span><br></pre></td></tr></table></figure>

<p>3.EL表达式</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_16-12-08.png"></p>
<p>4.JSTL</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_16-14-00.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_16-19-56.png"></p>
<h3 id="五-会话跟踪技术"><a href="#五-会话跟踪技术" class="headerlink" title="五.会话跟踪技术"></a>五.会话跟踪技术</h3><p>会话：用户打开浏览器，访问web服务器的资源， 会话建立，直到有一方断开连接，会话结束。在一次会话中<br>可以包含多次请求和响应<br>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话<br>的多次请求间共享数据<br>HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求， 因此我们需要会话跟踪技术来实现会话内数据共享<br>实现方式：<br>1.客户端会话跟踪技术：Cookie<br>2.服务端会话跟踪技术：Session</p>
<h4 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_20-13-50.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_20-15-58.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_20-20-10.png"></p>
<h4 id="2-Session"><a href="#2-Session" class="headerlink" title="2.Session"></a>2.Session</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_20-23-51.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_20-26-14.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-24_20-29-15.png"></p>
<h3 id="六-AJAX"><a href="#六-AJAX" class="headerlink" title="六.AJAX"></a>六.AJAX</h3><p>概念：AJAX(Asynchronous JavaScript And XML）：异步的JavaScript和XML<br>AJAX作用：</p>
<ol>
<li>与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据<br>使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了</li>
<li>异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用<br>户名是否可用校验，等等…</li>
</ol>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-26_19-57-21.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-26_20-04-14.png"></p>
<h4 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h4><p><a href="https://www.axios-http.cn/">Axios</a>是对AJAX的代码进行封装以达到简化AJAX的目的</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-26_20-11-53.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-26_20-21-03.png"></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>概念：JavaScript t Object Notation JavaScript对象表示法<br>由于其语法简单， 层次结构鲜明， 现多用于作为数据载体，在网络中进行数据传输</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-26_20-42-15.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-26_20-44-17.png"></p>
<h3 id="七-vue"><a href="#七-vue" class="headerlink" title="七.vue"></a>七.vue</h3><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-40-57.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-43-54.png"></p>
<h4 id="vue常用指令"><a href="#vue常用指令" class="headerlink" title="vue常用指令"></a>vue常用指令</h4><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-56-56.png"></p>
<h5 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h5><h5 id="v–on"><a href="#v–on" class="headerlink" title="v–on"></a>v–on</h5><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-57-37.png"></p>
<h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><h5 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h5><h5 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h5><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-58-05.png"></p>
<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-58-31.png"></p>
<h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4><p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_12-54-40.png"></p>
<h3 id="八-Element"><a href="#八-Element" class="headerlink" title="八.Element"></a>八.Element</h3><p><a href="https://element.eleme.cn/#/zh-CN">element</a>是基于vue2的,如果导入vue3的js会导致element样式失效</p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_13-13-27.png"></p>
<p><img src="D:\myblog\source_posts\java-web\Snipaste_2022-10-27_14-05-11.png"></p>
<h3 id="九综合练习"><a href="#九综合练习" class="headerlink" title="九综合练习"></a>九综合练习</h3><h4 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h4><h5 id="1-创建项目-选择maven项目框架"><a href="#1-创建项目-选择maven项目框架" class="headerlink" title="(1)创建项目,选择maven项目框架"></a>(1)创建项目,选择maven项目框架</h5><h5 id="2-创建pojo类"><a href="#2-创建pojo类" class="headerlink" title="(2)创建pojo类"></a>(2)创建pojo类</h5><p>根据数据库创建实体类</p>
<h5 id="3-配置maven的pom-xml文件"><a href="#3-配置maven的pom-xml文件" class="headerlink" title="(3)配置maven的pom.xml文件"></a>(3)配置maven的pom.xml文件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>     <span class="comment">&lt;!--改变打包方式,war为web项目用包--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--导入jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入jdbc--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!--导入servlet--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!--导入jsp--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!--tomcat插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-配置mybaties和mapper"><a href="#4-配置mybaties和mapper" class="headerlink" title="(4)配置mybaties和mapper"></a>(4)配置mybaties和mapper</h5><p>在resources资源下配置mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--链接数据库--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/website?useSSL=false&quot;</span>/&gt;</span>         </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1546139844&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--链接mapper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.Mapper&quot;</span>/&gt;</span>        <span class="comment">&lt;!--值为mapper接口和配置文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置mapper接口和配置文件(名称和路径要求相同)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.Mapper.EMapper&quot;</span>&gt;</span>         <span class="comment">&lt;!--名称空间为mapper接口--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--resultMap根据使用和pojo类进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;websitemap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.yyl.pojo.Website&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;domain&quot;</span> <span class="attr">property</span>=<span class="string">&quot;domain&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">property</span>=<span class="string">&quot;tags&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectall&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;websitemap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            select * from website <span class="tag">&lt;<span class="name">where</span>&gt;</span><span class="tag">&lt;/<span class="name">where</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into website(name, domain,tags) VALUES</span><br><span class="line">    (#&#123;name&#125;,#&#123;domain&#125;,#&#123;tags&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update website</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;domain!=null and domain!=&#x27;&#x27;&quot;</span>&gt;</span> domain=#&#123;domain&#125; ,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span> name=#&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;tags!=null&quot;</span>&gt;</span>           tags=#&#123;tags&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;Odelete&quot;</span>&gt;</span></span><br><span class="line">        delete from website where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectuser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.yyl.pojo.user&quot;</span>&gt;</span></span><br><span class="line">        select * from user where username=#&#123;username&#125; and password=#&#123;password&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建SqlSessionFactoryUtils类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-配置servlet环境"><a href="#5-配置servlet环境" class="headerlink" title="(5)配置servlet环境"></a>(5)配置servlet环境</h5><p>创建Servlet类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/tableservlet&quot;)</span>    <span class="comment">//路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableSevrlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-创建service对象"><a href="#6-创建service对象" class="headerlink" title="(6)创建service对象"></a>(6)创建service对象</h5><p>首先创建service接口,方法对应mapper中的方法</p>
<p>创建service类,对方法进行重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YylServiceimpl</span> <span class="keyword">implements</span> <span class="title class_">YylService</span> &#123;</span><br><span class="line">    <span class="comment">//创建工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SqlSessionFactoryUtils.getSqlSessionFactory();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;yyl&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSessionp=factory.openSession();</span><br><span class="line">        <span class="comment">//获取EMapper</span></span><br><span class="line">        <span class="type">EMapper</span> <span class="variable">eMapper</span> <span class="operator">=</span>sqlSessionp.getMapper(EMapper.class);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        List&lt;yyl&gt; yyls=eMapper.selectAll();</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSessionp.close();</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> yyls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-创建静态网页资源"><a href="#6-创建静态网页资源" class="headerlink" title="(6)创建静态网页资源"></a>(6)创建静态网页资源</h5><p>在main文件下创建wabapp存放静态页面,包括html,js,css,img等文件夹</p>
<h5 id="7-事例"><a href="#7-事例" class="headerlink" title="(7)事例"></a>(7)事例</h5><p>以查询所有为例子展示</p>
<p>后端:</p>
<p>在mapper类和mapper配置文件和service类和servlet类的中实现相应代码</p>
<p>servlet:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line">List&lt;yyl&gt; yyls =yylservice.selectAll();</span><br><span class="line"><span class="comment">//转JSON</span></span><br><span class="line"><span class="type">String</span> <span class="variable">toyyls</span> <span class="operator">=</span>JSON.toJSONString(yyls);</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line">resp.getWriter().write(toyyls);</span><br></pre></td></tr></table></figure>

<p>前端:</p>
<p>静态页面:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue2.7.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> _this=<span class="variable language_">this</span>;</span></span><br><span class="line"><span class="language-javascript">            axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8080/JavaWeb/tableservlet&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;_this.<span class="property">tableData</span>=resp.<span class="property">data</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            &lt;!--表格类型--&gt;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">tableRowClassName</span>(<span class="params">&#123;row, rowIndex&#125;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (rowIndex === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="string">&#x27;warning-row&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowIndex === <span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="string">&#x27;success-row&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">tableData</span>: []</span></span><br><span class="line"><span class="language-javascript">        &#125;&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2022/08/16/leetcode/</url>
    <content><![CDATA[<p>C++解法</p>
<p>在java解法中有注释</p>
<h5 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h5><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">count</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">twosum</span>(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        i=<span class="number">0</span>;j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;nums.<span class="built_in">size</span>();j++;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[j]==target)</span><br><span class="line">                 <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>() &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    count y ;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v=y.<span class="built_in">twosum</span>(nums,<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;&#123;&#x27;</span>&lt;&lt;v[<span class="number">0</span>]&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;v[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h5><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头(此算法太繁琐在java解题中进行了改进)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) :<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x,ListNode *next) : <span class="built_in">val</span>(x) ,<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode*l1,ListNode*l2)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> y =<span class="number">0</span>;</span><br><span class="line">        ListNode*p=l1;</span><br><span class="line">        ListNode*q=l2;</span><br><span class="line">        ListNode*head =<span class="keyword">new</span> ListNode;</span><br><span class="line">        head -&gt;val =<span class="number">0</span> ;</span><br><span class="line">        head -&gt;next =<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode*m=head;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="literal">nullptr</span> &amp;&amp; p!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val + q-&gt;val+y &gt;=<span class="number">10</span> )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a = p-&gt;val + q-&gt;val+y;</span><br><span class="line">        a =a%<span class="number">10</span>;</span><br><span class="line">        ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">        n-&gt;val=a;</span><br><span class="line">        n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        m-&gt;next=n;</span><br><span class="line">        m=n;</span><br><span class="line">        y =<span class="number">1</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="type">int</span> a = p-&gt;val + q-&gt;val+y;</span><br><span class="line">        ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">        n-&gt;val=a;</span><br><span class="line">        n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        m-&gt;next=n;</span><br><span class="line">        m=n;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="literal">nullptr</span> &amp;&amp;q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (q-&gt;val+y &gt;=<span class="number">10</span> )&#123;</span><br><span class="line">    </span><br><span class="line">                 <span class="type">int</span> a = q-&gt;val+y;</span><br><span class="line">                 a =a%<span class="number">10</span>;</span><br><span class="line">                 ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">                 n-&gt;val=a;</span><br><span class="line">                 n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                 m-&gt;next=n;</span><br><span class="line">                 m=n;</span><br><span class="line">                 y =<span class="number">1</span>;</span><br><span class="line">                 q=q-&gt;next;</span><br><span class="line">                                        &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">                 <span class="type">int</span> a = q-&gt;val+y;</span><br><span class="line">                 ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">                 n-&gt;val=a;</span><br><span class="line">                 n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                 m-&gt;next=n;</span><br><span class="line">                 m=n;</span><br><span class="line">                 y=<span class="number">0</span>;</span><br><span class="line">                 q=q-&gt;next;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                   <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;val+y &gt;=<span class="number">10</span> )&#123;</span><br><span class="line">    </span><br><span class="line">                 <span class="type">int</span> a = p-&gt;val+y;</span><br><span class="line">                 a =a%<span class="number">10</span>;</span><br><span class="line">                 ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">                 n-&gt;val=a;</span><br><span class="line">                 n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                 m-&gt;next=n;</span><br><span class="line">                 m=n;</span><br><span class="line">                 y =<span class="number">1</span>;</span><br><span class="line">                 p=p-&gt;next;</span><br><span class="line">                                        &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">                 <span class="type">int</span> a = p-&gt;val+y;</span><br><span class="line">                 ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">                 n-&gt;val=a;</span><br><span class="line">                 n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                 m-&gt;next=n;</span><br><span class="line">                 m=n;</span><br><span class="line">                 y=<span class="number">0</span>;</span><br><span class="line">                 p=p-&gt;next;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> a = y;</span><br><span class="line">                 ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">                 n-&gt;val=a;</span><br><span class="line">                 n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                 m-&gt;next=n;</span><br><span class="line">                 m=n;</span><br><span class="line">                 y=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (y==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> a = y;</span><br><span class="line">                 ListNode*n = <span class="keyword">new</span> ListNode;</span><br><span class="line">                 n-&gt;val=a;</span><br><span class="line">                 n-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">                 m-&gt;next=n;</span><br><span class="line">                 m=n;</span><br><span class="line">                 y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    ListNode*l3=head-&gt;next;</span><br><span class="line">    <span class="built_in">delete</span>(head);</span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-最长字串"><a href="#3-最长字串" class="headerlink" title="3.最长字串"></a>3.最长字串</h5><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">     int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int i=0 ,j=1,n=1,m=0;</span><br><span class="line">        while (s[i]!=&#x27;\0&#x27;) &#123;</span><br><span class="line">        while (s[j]!=&#x27;\0&#x27;) &#123;</span><br><span class="line">         int a=0;</span><br><span class="line">        for (int l=i; l&lt;j; l++) &#123;</span><br><span class="line">        if (s[l]==s[j]) &#123;</span><br><span class="line">        a =0;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        a =1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a==1) &#123;</span><br><span class="line">        n=n+1;</span><br><span class="line">        j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n&gt;m) &#123;</span><br><span class="line">        m=n;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        if (j==i) &#123;</span><br><span class="line">        j=j+1;</span><br><span class="line">        n=1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        n=n-1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-中位数"><a href="#4-中位数" class="headerlink" title="4.中位数"></a>4.中位数</h5><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sum;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>()) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>()) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt; nums1.<span class="built_in">size</span>() &amp;&amp; n &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">                        sum.<span class="built_in">push_back</span>(nums2[n]);</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sum.<span class="built_in">push_back</span>(nums1[m]);</span><br><span class="line">                        m++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; nums1.<span class="built_in">size</span>() &amp;&amp; n &gt;= nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum.<span class="built_in">push_back</span>(nums1[m]);</span><br><span class="line">                    m++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= nums1.<span class="built_in">size</span>() &amp;&amp; n &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum.<span class="built_in">push_back</span>(nums2[n]);</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">double</span>((sum[sum.<span class="built_in">size</span>() - <span class="number">1</span>] + sum[sum.<span class="built_in">size</span>() - <span class="number">2</span>])) / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt; nums1.<span class="built_in">size</span>() &amp;&amp; n &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums1[m] &gt; nums2[n]) &#123;</span><br><span class="line">                        sum.<span class="built_in">push_back</span>(nums2[n]);</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sum.<span class="built_in">push_back</span>(nums1[m]);</span><br><span class="line">                        m++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; nums1.<span class="built_in">size</span>() &amp;&amp; n &gt;= nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum.<span class="built_in">push_back</span>(nums1[m]);</span><br><span class="line">                    m++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; nums2.<span class="built_in">size</span>() &amp;&amp; m &gt;= nums1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum.<span class="built_in">push_back</span>(nums2[n]);</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (sum[(nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="5-回文子串"><a href="#5-回文子串" class="headerlink" title="5.回文子串"></a>5.回文子串</h5><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string s1=s;</span><br><span class="line">        string ls;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; s[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+ls.<span class="built_in">size</span>(); j&lt;s.<span class="built_in">size</span>()&amp;&amp;s[j]!=<span class="string">&#x27;\0&#x27;</span>; j++) &#123;</span><br><span class="line">        <span class="type">int</span> n=i;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;s1[<span class="number">0</span>],&amp;s[i], j-i+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m=j-i;</span><br><span class="line">        n=i;</span><br><span class="line">        <span class="keyword">for</span> (; m&gt;=<span class="number">0</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[m]==s[n]) &#123;n++;m--;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span> (m&gt;=<span class="number">0</span>) &#123;&#125;</span><br><span class="line">       <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls.<span class="built_in">size</span>()&lt;j-i+<span class="number">1</span>) &#123;</span><br><span class="line">           ls=s1.<span class="built_in">substr</span>(<span class="number">0</span>,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="6-z字型排列"><a href="#6-z字型排列" class="headerlink" title="6.z字型排列"></a>6.z字型排列</h5><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。请你实现这个将字符串进行指定行数变换的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">        string s1=s;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*m*(numRows<span class="number">-1</span>)&lt;s.<span class="built_in">size</span>()) </span><br><span class="line">        s1[i]=s[<span class="number">2</span>*m*(numRows<span class="number">-1</span>)];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;numRows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=numRows-j;</span><br><span class="line">         <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*m*(numRows<span class="number">-1</span>)+j&lt;s.<span class="built_in">size</span>()) </span><br><span class="line">        s1[i]=s[<span class="number">2</span>*m*(numRows<span class="number">-1</span>)+j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*(n<span class="number">-1</span>)+<span class="number">2</span>*m*(numRows<span class="number">-1</span>)+j&lt;s.<span class="built_in">size</span>()) </span><br><span class="line">        s1[i]=s[<span class="number">2</span>*(n<span class="number">-1</span>)+<span class="number">2</span>*m*(numRows<span class="number">-1</span>)+j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         i++;</span><br><span class="line">         m++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>*m*(numRows<span class="number">-1</span>)+numRows<span class="number">-1</span>&lt;s.<span class="built_in">size</span>()) </span><br><span class="line">        s1[i]=s[<span class="number">2</span>*m*(numRows<span class="number">-1</span>)+numRows<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="7-数字反转"><a href="#7-数字反转" class="headerlink" title="7.数字反转"></a>7.数字反转</h5><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ts=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">2147483647</span>;</span><br><span class="line">        <span class="type">int</span> min=<span class="number">-2147483648</span>;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ts&gt;max/<span class="number">10</span>||ts&lt;min/<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t=x%<span class="number">10</span>;</span><br><span class="line">        ts=ts*<span class="number">10</span>+t;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_JAVA</title>
    <url>/2022/10/05/leetcode-JAVA/</url>
    <content><![CDATA[<h5 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h5><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">leetcode1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] TwoSum(<span class="type">int</span> [] nums,<span class="type">int</span> target)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        i=<span class="number">0</span>;j=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> [] sum=<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;nums.length;j++)</span><br><span class="line">                <span class="keyword">if</span> (nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    sum [<span class="number">0</span>]=i;sum [<span class="number">1</span>]=j;</span><br><span class="line">                    <span class="keyword">return</span> sum;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h5><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">leetcode2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span><span class="number">0</span>;                                      <span class="comment">//用y记录两数相加是否大于十</span></span><br><span class="line">        ListNode p=l1;                                <span class="comment">//p指向l1第一个节点</span></span><br><span class="line">        ListNode q=l2;									<span class="comment">//q指向l2第一个节点</span></span><br><span class="line">        ListNode q_f=l2;								<span class="comment">//q_f指向q的前一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="literal">null</span> &amp;&amp; p!=<span class="literal">null</span>) &#123;                   <span class="comment">//首先计算l1和l2长度相同的节点值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> p.val + q.val+y;                  <span class="comment">//y是上两个后大于十时候进的1</span></span><br><span class="line">            q.val=a%<span class="number">10</span>;                                <span class="comment">//将和存放在q中</span></span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">10</span>)									<span class="comment">//判断和是否要进1</span></span><br><span class="line">                y = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y = <span class="number">0</span>;</span><br><span class="line">            p=p.next;                                  <span class="comment">//p指向下一个节点</span></span><br><span class="line">            q_f=q;                                     <span class="comment">//q_f指向当前q节点</span></span><br><span class="line">            q=q.next;								<span class="comment">//q指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前的状态是l1和l2相同长度的部分已经加完并且存放在l2当中,进数存放在y中,下一步需要将l1或l2中多出去的节点接在l2后面,即需要使得q_f节点的next指针指向多余节点的第一个节点,q节点指向多于节点的第一个节点.(若长的链表为l2则本身就满足此情况即不需要操作)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(q==<span class="literal">null</span> &amp;&amp;p!=<span class="literal">null</span>)					</span><br><span class="line">        &#123;q_f.next=p;q=q_f.next;&#125;                      <span class="comment">//完成上述操作</span></span><br><span class="line">        <span class="keyword">if</span>(y==<span class="number">0</span>)                                     <span class="comment">//没有需要进的数则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="literal">null</span>)&#123;                             <span class="comment">//两链表长度相同且需要进1</span></span><br><span class="line">                ListNode last=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>,<span class="literal">null</span>);  <span class="comment">//新建节点值为1接在q_f后面</span></span><br><span class="line">                q_f.next=last;</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (q!=<span class="literal">null</span> &amp;&amp; q.val==<span class="number">9</span>)         <span class="comment">//只要节点值为9才需要继续操作否则直接加一即可,所以找到最后一个q的节点,并且使得走过节点的值都为0(9+1=10),y不变还为1</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.val=<span class="number">0</span>;</span><br><span class="line">                    q_f=q;</span><br><span class="line">                    q=q.next;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q==<span class="literal">null</span>)                      <span class="comment">//如果最后一个9是最后一个节点(类似19999999),新建节点值为1链接在最后</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ListNode last=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>,<span class="literal">null</span>);</span><br><span class="line">                    q_f.next=last;</span><br><span class="line">                    <span class="keyword">return</span> l2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;q.val=q.val+<span class="number">1</span>;&#125;              <span class="comment">//否则直接加一返回</span></span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-最长字串"><a href="#3-最长字串" class="headerlink" title="3.最长字串"></a>3.最长字串</h5><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">leetcode3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] schar= <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];             <span class="comment">//字符串转为schar字符数组</span></span><br><span class="line">        schar=s.toCharArray();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span> ,j=<span class="number">1</span>,n=<span class="number">1</span>,m=<span class="number">0</span>;                       <span class="comment">//n记录当前的无重子串长度,m记录历史中最长的无重子串长度</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;s.length()) &#123;                     </span><br><span class="line">            <span class="keyword">while</span> (j&lt;s.length()) &#123;</span><br><span class="line">                <span class="type">int</span> a=<span class="number">0</span>;							<span class="comment">//a记录是否有重复字符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l=i; l&lt;j; l++) &#123;          <span class="comment">//检查从i到j是否有重复</span></span><br><span class="line">                    <span class="keyword">if</span> (schar[l]==schar[j]) &#123;</span><br><span class="line">                        a =<span class="number">0</span>;                      <span class="comment">//若有重复,a置为0;跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        a =<span class="number">1</span>;                       <span class="comment">//无重复a置为1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a==<span class="number">1</span>) &#123;                        <span class="comment">//无重复,当前无重复子串长度加一</span></span><br><span class="line">                    n=n+<span class="number">1</span>;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;                         <span class="comment">//有重复直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n&gt;m) &#123;                             <span class="comment">//如果当前子串长度大于记载的最大值则替换</span></span><br><span class="line">                m=n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;                              <span class="comment">//若无重复从下一个i开始继续检测</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(j==i)&#123; j=j+<span class="number">1</span>;n=<span class="number">1</span>;&#125;             <span class="comment">//若ji相等则j加一,无重复子串长度为一</span></span><br><span class="line">                <span class="keyword">else</span>&#123; n=n-<span class="number">1</span>;&#125;                     <span class="comment">//i进了一位所以当前无重复子串减少一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;                                 <span class="comment">//如果有重复则从重复字符下一位开始检测</span></span><br><span class="line">                <span class="keyword">if</span>(i==l+<span class="number">1</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> cont=l+<span class="number">1</span>-i;</span><br><span class="line">                i=l+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==i)&#123; j=j+<span class="number">1</span>;n=<span class="number">1</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; n=n-cont;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-中位数"><a href="#4-中位数" class="headerlink" title="4.中位数"></a>4.中位数</h5><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> first.f1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">leetcode4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; nums3=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();         <span class="comment">//nums3是动态数组</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums1.length &amp;&amp;j&lt;nums2.length)             <span class="comment">//依次比较数组大小</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (nums1[i]&lt;nums2[j])</span><br><span class="line">                nums3.add(nums1[i++]);                    <span class="comment">//将小的值放入动态数组中</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums3.add(nums2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==nums1.length)                             <span class="comment">//将数组的剩余部分放入动态数组中</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;nums2.length)</span><br><span class="line">                nums3.add(nums2[j++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;nums1.length)</span><br><span class="line">                nums3.add(nums1[i++]);</span><br><span class="line">        <span class="keyword">if</span> ((nums1.length+nums2.length)%<span class="number">2</span>==<span class="number">1</span>)           <span class="comment">//根据动态数组长度,返回中位数</span></span><br><span class="line">            <span class="keyword">return</span> nums3.get((nums1.length+nums2.length-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ((<span class="type">double</span>)nums3.get((nums1.length+nums2.length-<span class="number">1</span>)/<span class="number">2</span>)+(<span class="type">double</span>)nums3.get((nums1.length+nums2.length-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-回文子串"><a href="#5-回文子串" class="headerlink" title="5.回文子串"></a>5.回文子串</h5><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">leetcode5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1=<span class="keyword">new</span> <span class="title class_">char</span>[s.length()];          <span class="comment">//s1相当于s的字符数组</span></span><br><span class="line">        s1=s.toCharArray();                     </span><br><span class="line">        <span class="type">char</span>[] s2=<span class="keyword">new</span> <span class="title class_">char</span>[s.length()];			 <span class="comment">//用s2来匹配是否是回文字串</span></span><br><span class="line">        s2=s.toCharArray();</span><br><span class="line">        <span class="type">int</span> cont=<span class="number">0</span>;                              <span class="comment">//cont为回文子串长度</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;                             <span class="comment">//start为回文子串开始的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;       <span class="comment">//从s1的第一个字符开始匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+cont;j&lt;s.length(); j++) &#123; <span class="comment">//从s2与s1相同的位置加上当前记录的最大回文子串的长度开始匹配</span></span><br><span class="line">                <span class="type">int</span> n=i;                           <span class="comment">//用m和n代替j和i防止j和i改变</span></span><br><span class="line">                <span class="type">int</span> m=j;</span><br><span class="line">                <span class="keyword">for</span> (; m&gt;=i; ) &#123;                   <span class="comment">//如果字符等则依次匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (s2[m]==s1[n]) &#123;n++;m--;&#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;                    <span class="comment">//如果不等则跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m&gt;=i) &#123;&#125;                         <span class="comment">//如果m大于i说明没有匹配完即i到j中间不是回文子串</span></span><br><span class="line">                <span class="keyword">else</span>  &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cont&lt;j-i+<span class="number">1</span>) &#123;               <span class="comment">//是回文子串则计算当前最大长度是否大于此回文子串长度,如果小于则替换</span></span><br><span class="line">                        cont=j-i+<span class="number">1</span>;</span><br><span class="line">                        start=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] s4=<span class="keyword">new</span> <span class="title class_">char</span>[cont];                <span class="comment">//s4存放最大回文子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;cont;i++)                 <span class="comment">//从start开始的cont个字符就是最大回文子串</span></span><br><span class="line">            s4[i]=s1[start++];</span><br><span class="line">        String s5=<span class="keyword">new</span> <span class="title class_">String</span>(s4);</span><br><span class="line">        <span class="keyword">return</span> s5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab</title>
    <url>/2022/09/28/matlab/</url>
    <content><![CDATA[<p>一.清空</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all :清除workspace所以变量.</span><br><span class="line"></span><br><span class="line">clc : 清除命令.</span><br></pre></td></tr></table></figure>

<p>二.注释</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%注释内容</span></span><br></pre></td></tr></table></figure>

<p>三.数据类型</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span>                      <span class="comment">%数字</span></span><br><span class="line">ch=<span class="string">&#x27;a&#x27;</span>                   <span class="comment">%字符</span></span><br><span class="line"><span class="built_in">abs</span>(ch)                  <span class="comment">%ascll码</span></span><br><span class="line">char(<span class="number">97</span>)                 <span class="comment">%ascll为97的字符</span></span><br><span class="line">num2str(<span class="number">65</span>)              <span class="comment">%ans=65</span></span><br><span class="line">name=<span class="string">&#x27;zhangsan&#x27;</span>          <span class="comment">%字符串</span></span><br><span class="line"><span class="built_in">length</span>(name)             <span class="comment">%计算字符串长度</span></span><br><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>] <span class="comment">%矩阵</span></span><br><span class="line">B=A&#x27;                     <span class="comment">%矩阵转置</span></span><br><span class="line">C=A(:)                   <span class="comment">%矩阵竖着排列</span></span><br><span class="line">D=inv(A)                 <span class="comment">%矩阵求逆矩阵</span></span><br><span class="line">E=<span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>)          <span class="comment">%10行 5列 三维矩阵 数值都为零</span></span><br><span class="line">E(:,:,<span class="number">1</span>) =<span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">E(:,:,<span class="number">2</span>) =<span class="built_in">randn</span>(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">E(:,:,<span class="number">3</span>) =randi(<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">A=cell(<span class="number">6</span>,<span class="number">6</span>)              <span class="comment">%六行六列元胞数组</span></span><br><span class="line">A=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;=<span class="built_in">eye</span>(<span class="number">3</span>)           <span class="comment">%使得A的一行二列的值为三行三列的单位矩阵</span></span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">3</span>&#125;=<span class="built_in">magic</span>(<span class="number">5</span>)          <span class="comment">%五行五列的列阵,行列相加值相等</span></span><br><span class="line">B=A&#123;<span class="number">1</span>,<span class="number">3</span>&#125;                 <span class="comment">%赋值</span></span><br><span class="line">books = struct (<span class="string">&#x27;name&#x27;</span>,&#123;&#123;<span class="string">&#x27;zhngsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>&#125;&#125;,<span class="string">&#x27;price&#x27;</span>,[<span class="number">30</span> <span class="number">40</span>])<span class="comment">%结构体</span></span><br><span class="line">books.name(<span class="number">1</span>)            <span class="comment">%取细胞</span></span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;            <span class="comment">%取值</span></span><br></pre></td></tr></table></figure>

<p>四.随机数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rand</span>                     <span class="comment">%0到1伪随机数</span></span><br><span class="line"><span class="built_in">rand</span>(m,n)                <span class="comment">%m行n列0到1伪随机数矩阵</span></span><br><span class="line"><span class="built_in">randn</span>                    <span class="comment">%标准正态分布伪随机数</span></span><br><span class="line"><span class="built_in">rand</span>(m,n)                <span class="comment">%m行n列标准正态分布伪随机数矩阵</span></span><br><span class="line">randi([<span class="built_in">min</span>,<span class="built_in">max</span>])         <span class="comment">%区间内伪随机整数</span></span><br><span class="line">randi([<span class="built_in">min</span>,<span class="built_in">max</span>],m,n)     </span><br></pre></td></tr></table></figure>

<p>五.矩阵</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">3</span> <span class="number">2</span> <span class="number">7</span>] <span class="comment">%矩阵</span></span><br><span class="line">B=A&#x27;                     <span class="comment">%矩阵转置</span></span><br><span class="line">C=A(:)                   <span class="comment">%矩阵竖着排列</span></span><br><span class="line">D=inv(A)                 <span class="comment">%矩阵求逆矩阵</span></span><br><span class="line">E=<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>                  <span class="comment">%1到9每隔2去一个数字</span></span><br><span class="line">F=<span class="built_in">repmat</span>(E,<span class="number">3</span>,<span class="number">3</span>)          <span class="comment">%把E矩阵三行三列重复</span></span><br><span class="line">D=<span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">4</span>)              <span class="comment">%四行四列的值为一的矩阵</span></span><br><span class="line">A .* B                   <span class="comment">%对应项相乘</span></span><br><span class="line">A / B                    <span class="comment">%A乘以B的逆</span></span><br><span class="line">A ./ B                   <span class="comment">%对应项相除</span></span><br><span class="line">C=A(<span class="number">3</span>,:)                 <span class="comment">%取A的第三行</span></span><br><span class="line">[m,n] = <span class="built_in">find</span>(A&gt;<span class="number">20</span>)       <span class="comment">%找到A中大于二十的值的序列</span></span><br></pre></td></tr></table></figure>

<p>六.程序结构</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">1</span>:<span class="number">10</span>             <span class="comment">%从1开始每次加1到10为止</span></span><br><span class="line">a=a+n;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> n&lt;<span class="number">10</span></span><br><span class="line">n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">otherwise</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>七.二维绘图</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">10</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,y)</span><br><span class="line">title(<span class="string">&#x27;y=sin(x)&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>)</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>:</span><br><span class="line">y1=<span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x):</span><br><span class="line">y2=<span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x):</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">[AX,HI,H2]=plotyy(x,y1,x,y2,<span class="string">&#x27;plot&#x27;</span>)                 <span class="comment">%公用一个x轴绘图</span></span><br><span class="line">set (get (AX(<span class="number">1</span>);<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Slow Decay&#x27;</span>)</span><br><span class="line">set (get (AX(<span class="number">2</span>);<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;Fast Decay&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time (\musec)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Multiple Decay Rates&#x27;</span>)</span><br><span class="line">set(H1,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">set(H2,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="built_in">plot3</span>(<span class="built_in">sin</span>(t),<span class="built_in">cos</span>(t),t)  <span class="comment">%三维绘图</span></span><br><span class="line">xlabel(<span class="string">&#x27;sin(t)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;cos(t)&#x27;</span>)</span><br><span class="line">zlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">grid on               <span class="comment">%网格</span></span><br><span class="line">axis square           <span class="comment">%正方体</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2022/10/19/maven/</url>
    <content><![CDATA[<h3 id="maven概述"><a href="#maven概述" class="headerlink" title="maven概述"></a>maven概述</h3><p>Maven是专门用于管理和构建ava项目的工具，它的主要功能有：</p>
<blockquote>
<p>提供了一套标准化的项目结构<br>提供了一套标准化的构建流程(编译，测试，打包，发布…)<br>提供了一套依赖管理机制</p>
</blockquote>
<h3 id="maven简介"><a href="#maven简介" class="headerlink" title="maven简介"></a>maven简介</h3><p>Apache Maven是一个项目管理和构建工具，它基于项目对象模型<br>(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档<br>官网：<a href="http://maven.apache.org/">http://maven.apache.org/</a></p>
<p><img src="D:\myblog\source_posts\maven\Snipaste_2022-10-19_19-01-06.png"></p>
<h3 id="maven安装和配置"><a href="#maven安装和配置" class="headerlink" title="maven安装和配置"></a>maven安装和配置</h3><p>1.安装</p>
<p>官网下载后直接解压</p>
<p>2.配置</p>
<p>配置环境变量</p>
<p>在.\conf\setings.xml中  配置jar包位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>

<p>配置阿里云私服   加速jar包下载</p>
<h3 id="maven基本使用"><a href="#maven基本使用" class="headerlink" title="maven基本使用"></a>maven基本使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile      编译</span><br><span class="line">mvn clear        清理编译文件</span><br><span class="line">mvn package      打包</span><br><span class="line">mvn test         测试</span><br><span class="line">mvn install      将项目安装到本地仓库</span><br></pre></td></tr></table></figure>

<p>Maven生命周期<br>Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件<br>Maven对项目构建的生命周期划分为3套<br>clean:清理工作<br>default:核心工作，例如编译，测试，打包，安装等<br>site:产生报告，发布站点等</p>
<p><img src="D:\myblog\source_posts\maven\Snipaste_2022-10-19_19-55-16.png"></p>
<h4 id="IDEA-配置Maven"><a href="#IDEA-配置Maven" class="headerlink" title="IDEA 配置Maven"></a>IDEA 配置Maven</h4><p>在IDEA中  File—-setting—-搜索maven  设置  最后三个路径 (maven路径,配置文件路径,仓库路径)</p>
<h4 id="坐标-dependency"><a href="#坐标-dependency" class="headerlink" title="坐标(dependency)"></a>坐标(dependency)</h4><p>Maven中的坐标是资源的唯一标识<br>使用坐标来定义项目或引入项目中需要的依赖<br>Maven坐标主要组成<br>groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如：com.itheima)<br>artifactld:定义当前Maven.项目名称(通常是模块名称，例如order–service、goods-service)<br>version:定义当前项目版本号</p>
<h4 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h4><p>在创建module时选择maven即可</p>
<h4 id="导入maven项目"><a href="#导入maven项目" class="headerlink" title="导入maven项目"></a>导入maven项目</h4><p>点击右侧maven,点击加号,选择maven的配置文件即可</p>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>在setting—Plugins—搜索maven-help下载</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在官网<a href="https://mvnrepository.com/%E6%89%BE%E5%88%B0jar%E5%8C%85%E5%B0%86%E4%BB%A3%E7%A0%81%E6%94%BE%E5%9C%A8pom.xml%E4%B8%AD%E7%9A%84">https://mvnrepository.com/找到jar包将代码放在pom.xml中的</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>右键pom.xml在run moven选择reimport</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/10/09/mysql/</url>
    <content><![CDATA[<h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="一-MySQL安装和启动"><a href="#一-MySQL安装和启动" class="headerlink" title="一.MySQL安装和启动"></a>一.MySQL安装和启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.下载官网:MySQL(https://mysql.com/)</span><br><span class="line">2.启动</span><br><span class="line">(1)win+r services.msc</span><br><span class="line">(2)net start mysql80     net stop mysql80  </span><br><span class="line">3.客户端连接</span><br><span class="line">(1)MySQL提供的客户端命令行工具</span><br><span class="line">(2)终端输入 mysql [-h 127.0.0.1] [-P 3306] -u root -p   (需要配置环境变量)</span><br></pre></td></tr></table></figure>

<h4 id="二-SQL语法"><a href="#二-SQL语法" class="headerlink" title="二.SQL语法"></a>二.SQL语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.通用语法</span><br><span class="line">(1)SQL语句可以单行或多行书写，以分号结尾。</span><br><span class="line">(2)SQL语句可以使用空格/缩进来增强语句的可读性</span><br><span class="line">(3)MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</span><br><span class="line">(4)注释：</span><br><span class="line">单行注释：--注释内容或#注释内容（MySQL特有）</span><br><span class="line">多行注释：/*注释内容*/</span><br><span class="line">2.分类</span><br><span class="line">DDL Data Definition Language 数据定义语言，用来定义数据库对象（数据库，表，字段）</span><br><span class="line">DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改</span><br><span class="line">DQL Data Query Language 数据查询语言，用来查询数据库中表的记录</span><br><span class="line">DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限</span><br><span class="line">3.DDL</span><br><span class="line">(1)查询</span><br><span class="line">查询所有数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line">查询当前数据库</span><br><span class="line">SELECT DATABASE()；</span><br><span class="line">创建</span><br><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名[DEFAULT CHARSET 字符集][COLLATE 排序规则];</span><br><span class="line">删除</span><br><span class="line">DROP DATABASE [IF EXISTS]数据库名；</span><br><span class="line">使用</span><br><span class="line">USE 数据库名；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询当前数据库所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line">查询表结构</span><br><span class="line">DESC表名;</span><br><span class="line">查询指定表的建表语句</span><br><span class="line">SHOW CREATE TABLE表名;</span><br><span class="line"></span><br><span class="line">DDL-表操作-创建</span><br><span class="line">CREATE TABLE `表名`（</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释]，</span><br><span class="line">字段2 字段2类型[COMMENT 字段2注释]，</span><br><span class="line">字段3 字段3类型[COMMENT 字段3注释]，</span><br><span class="line">....</span><br><span class="line">字段n字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line">DDL-表操作-修改</span><br><span class="line">添加</span><br><span class="line">ALTER TABLE `表名` ADD 字段名 类型 [COMMENT 注释] [约束];</span><br><span class="line">修改数据类型</span><br><span class="line">ALTER TABLE `表名` MODIFY 字段名 新数据类型（长度）;</span><br><span class="line">修改字段名和字段类型</span><br><span class="line">ALTER TABLE `表名` CHANGE 旧字段名 新字段名 类型（长度）[COMMENT注释]【约束】;</span><br><span class="line">删除字段</span><br><span class="line">ALTER TABLE `表名` drop 字段名;</span><br><span class="line">修改表名</span><br><span class="line">ALTER TABLE `表名` RENAME TO 新表名;</span><br><span class="line">删除表</span><br><span class="line">DROP TABLE [IF EXIST] 表名;</span><br><span class="line">删除指定表,并重新创建表         //用于清空数据</span><br><span class="line">TRUNCATE TABLE 表名;</span><br><span class="line">重命名 ALTER TABLE old RENAME TO new;</span><br><span class="line"></span><br><span class="line">DML-添加数据</span><br><span class="line">INSERT INTO表名(字段名1，字段名2，)VALUES(值1，值2，);</span><br><span class="line">给全部字段添加数据</span><br><span class="line">INSERT INTO表名VALUES(值1，值2,);</span><br><span class="line">批量添加数据</span><br><span class="line">INSERT INT0表名(字段名1，字段名2，)VALUES(随1，值2，…)，(值1，值2，)，(值1，值2，)；</span><br><span class="line">INSERT INTO表名VALUES(值1，值2,)，(值1，值2，)，(值1，值2，);</span><br><span class="line"></span><br><span class="line">DML-修改数据</span><br><span class="line">UPDATE 表名 SET 字段名1=值1，字段名2=值2 [WHERE条件]；</span><br><span class="line"></span><br><span class="line">DML-删除数据</span><br><span class="line">DELETE FROM 表名[WHERE条件];</span><br><span class="line"></span><br><span class="line">DQL-语法</span><br><span class="line">SELECT</span><br><span class="line">	字段列表</span><br><span class="line">FROM</span><br><span class="line">	表名列表</span><br><span class="line">WHERE</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">	分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br><span class="line">	</span><br><span class="line">DOL-基本查询</span><br><span class="line">1.查询多个字段</span><br><span class="line">SELECT 字段1，字段2，字段3.FROM表名；</span><br><span class="line">SELECT*FROM表名；</span><br><span class="line">2.设置别名</span><br><span class="line">SELECT字段1[AS别名1]，字段2[AS别名2].FROM表名;</span><br><span class="line">3.去除重复记录</span><br><span class="line">SELECT DISTINCT 字段列表 FROM 表名；</span><br><span class="line"></span><br><span class="line">DQL-条件查询</span><br><span class="line">1,语法</span><br><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br><span class="line"></span><br><span class="line">DQL-聚合函数</span><br><span class="line">1.介绍</span><br><span class="line">将一列数据作为一个整体，进行纵向计算。</span><br><span class="line">2.常见聚合函数</span><br><span class="line">函数     功能</span><br><span class="line">count  统计数量</span><br><span class="line">max    最大值</span><br><span class="line">min    最小值</span><br><span class="line">avg    平均值</span><br><span class="line">sum      求和</span><br><span class="line"></span><br><span class="line">DQL-分组查询</span><br><span class="line">1.语法</span><br><span class="line">SELECT字段列表FROM表名[WHERE条件]GROUP BY分组字段名[HAVING分组后过滤条件];</span><br><span class="line">\G   将每个数据每行输出</span><br><span class="line"></span><br><span class="line">DQL-排序查询</span><br><span class="line">1.语法</span><br><span class="line">SELECT字段列表FROM表名ORDER BY字段1排序方式1，字段2排序方式2;</span><br><span class="line">2.排序方式</span><br><span class="line">ASC:升序（默认值）</span><br><span class="line">DESC:降序</span><br><span class="line"></span><br><span class="line">DQL-分页查询</span><br><span class="line">1.语法</span><br><span class="line">SELECT 字段列表 FROM 表名 LIMT 起始索引，查询记录数；</span><br><span class="line"></span><br><span class="line">DCL-管理用户</span><br><span class="line">1.查询用户</span><br><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user;</span><br><span class="line">2.创建用户</span><br><span class="line">CREATE USER&#x27;用户名&#x27;@&#x27;主机名&#x27;IDENTIFIED BY&#x27;密码&#x27;；</span><br><span class="line">3.修改用户密码</span><br><span class="line">ALTER USER&#x27;用户名&#x27;@&#x27;主机名&#x27;IDENTIFIED WITH mysgl_native_password BY&#x27;新密码&#x27;；</span><br><span class="line">4.删除用户</span><br><span class="line">DROP USER&#x27;用户名&#x27;@&#x27;主机名&#x27;；</span><br><span class="line"></span><br><span class="line">DCL-权限控制</span><br><span class="line">MySQL中定义了很多种权限，但是常用的就以下几种：</span><br><span class="line">权限					说明</span><br><span class="line">ALL,ALL PRIVILEGES	所有权限</span><br><span class="line">SELECT				查询数据</span><br><span class="line">INSERT				插入数据</span><br><span class="line">UPDATE				修改数据</span><br><span class="line">DELETE				删除数据</span><br><span class="line">ALTER				修改表</span><br><span class="line">DROP				删除数据库/表/视图</span><br><span class="line">CREATE				创建数据库/表</span><br><span class="line"></span><br><span class="line">DCL-权限控制</span><br><span class="line">1.查询权限</span><br><span class="line">SHOW GRANTS FOR&#x27;用户名&#x27;@&#x27;主机名&#x27;；</span><br><span class="line">2.授予权限</span><br><span class="line">GRANT权限列表ON数据库名.表名TO&#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">3.撤销权限</span><br><span class="line">REVOKE权限列表ON 数据库名.表名FROM‘用户名&#x27;@&#x27;主机名&#x27;；;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-09_13-15-02.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-09_13-18-11.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-09_13-18-53.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-09_16-32-06.png"></p>
<h4 id="三-函数"><a href="#三-函数" class="headerlink" title="三.函数"></a>三.函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL中内置了很多字符串函数，常用的几个如下：</span><br><span class="line">函数											功能</span><br><span class="line">CONCAT(S1,S2,...Sn)				字符串拼接，将S1,S2,.Sn拼接成一个字符串</span><br><span class="line">LOWER(str)						将字符串str全部转为小写</span><br><span class="line">UPPER(str)						将字符串str全部转为大写</span><br><span class="line">LPAD(str,n,pad)					左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</span><br><span class="line">RPAD(str,n,pad)					右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</span><br><span class="line">TRIM(str)						去掉字符串头部和尾部的空格</span><br><span class="line">SUBSTRING(str,start,len)		返回从字符串str从stat位置起的len个长度的字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常见的数值函数如下：</span><br><span class="line">函数											功能	</span><br><span class="line">CEIL(x)                                     向上取整</span><br><span class="line">FLOOR(x)									向下取整</span><br><span class="line">MOD(x,y)									返回x/y的模</span><br><span class="line">RANDS										返回0~1内的随机数</span><br><span class="line">ROUND(x,y)									求参数x的四舍五入的值，保留y位小数</span><br><span class="line"></span><br><span class="line">常见的日期函数如下：</span><br><span class="line">函数											功能</span><br><span class="line">CURDATE（）								返回当前日期</span><br><span class="line">CURTIME（）								返回当前时间</span><br><span class="line">NOW（）									返回当前日期和时间</span><br><span class="line">YEAR(date)								 获取指定date的年份</span><br><span class="line">MONTH(date)								获取指定date的月份</span><br><span class="line">DAY(date)								获取指定date的日期</span><br><span class="line">DATE ADD(date,INTERVAL expr type)		返回一个日期/时间值加上一个时间间隔eXpr后的时间值</span><br><span class="line">DATEDIFF(date1,date2)					返回起始时间date1和结束时间date2之间的天数</span><br><span class="line"></span><br><span class="line">流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</span><br><span class="line">函数											功能</span><br><span class="line">IF(value,t,f)							如果value为true,则返回t,否则返回f</span><br><span class="line">IFNULL(value1,value2)					如果value1不为空，返回value1,否则返回value2</span><br><span class="line">CASE WHEN [val1 THEN [res1]...ELSE default END	如果vall为true,返回resl,.否则返回default默认值</span><br><span class="line">CASE expr WHEN [val THEN [res1]...ELSE default END	如果expr的值等于vall,返回resl,.否则返回default默认值</span><br></pre></td></tr></table></figure>

<h4 id="四-约束"><a href="#四-约束" class="headerlink" title="四.约束"></a>四.约束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念：约束是作用于表中字段上的规侧，用于限制存储在表中的数据。</span><br><span class="line">2.目的：保证数据库中数据的正确、有效性和完整性。</span><br><span class="line">3.分类：</span><br><span class="line">约束						描述										关键字</span><br><span class="line">非空约束			限制该字段的数据不能为nul							NOT NULL</span><br><span class="line">唯一约束			保证该字段的所有数据都是唯一、不重复的					UNIQUE</span><br><span class="line">主键约束			主键是一行数据的唯一标识，要求非空且唯一			PRIMARY KEY</span><br><span class="line">默认约束		保存数据时，如果未指定该字段的值，则采用默认值				DEFAULT</span><br><span class="line">检查约束(8.0.16版本之后)	保证字段值满足某一个条件						CHECK	</span><br><span class="line">外键约束		用来让两张表的数据之间建立连接，保证数据的一致性和完整性		FOREIGN KEY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">外键约束</span><br><span class="line">●语法</span><br><span class="line">添加外键</span><br><span class="line">CREATE TABLE表名（</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[CONSTRAINT]【外键名称】FOREIGN KEY（外键字段名）REFERENCES主表（主表列名）</span><br><span class="line">);</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY（外键字段名）REFERENCES 主表（主表列名）；</span><br><span class="line"></span><br><span class="line">外键约束</span><br><span class="line">删除/更新行为</span><br><span class="line">行为													说明</span><br><span class="line">NO ACTION		当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致)</span><br><span class="line">RESTRICT		当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除制更新。(与NO ACTION一致)</span><br><span class="line">CASCADE		当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。</span><br><span class="line">SET NULL			当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为ul(这就要求该外键允许取ul)</span><br><span class="line">SET DEFAULT			父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)</span><br><span class="line">ALTER TABLE表名 ADD CONSTRAINT 外键名称 FOREIGN KEY（外键字段）REFERENCES 主表名（主表字段名）ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>

<h4 id="五-多表查询"><a href="#五-多表查询" class="headerlink" title="五.多表查询"></a>五.多表查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多表关系:</span><br><span class="line">一对一:设立外键且唯一</span><br><span class="line">一对多:在多的一方设外键</span><br><span class="line">多对多:设立中间表,中间表两个外键指向两个表</span><br><span class="line"></span><br><span class="line">多表查询:</span><br><span class="line">select *from 表一,表二;</span><br><span class="line">select *from 表一 ,表二  where 表一.字段=表二.字段;</span><br><span class="line">select 别名一.字段 别名二.字段 from 表一 别名1,表二 别名二 where 别名一.字段=别名二.字段;</span><br><span class="line"></span><br><span class="line">多表查询分类: </span><br><span class="line">自连接:自己和自己</span><br><span class="line">内连接:俩个表交集</span><br><span class="line">(左)右外连接:左(右)表以及两表交集</span><br><span class="line"></span><br><span class="line">内连接查询语法：</span><br><span class="line">隐式内连接</span><br><span class="line">SELECT 字段列表 FROM 表1，表2 WHERE 条件..；</span><br><span class="line">显式内连接</span><br><span class="line">SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON连接条件...;</span><br><span class="line"></span><br><span class="line">外连接查询语法：</span><br><span class="line">左外连接</span><br><span class="line">SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...;</span><br><span class="line">相当于查询表1（左表）的所有数据包含表1和表2交集部分的数据</span><br><span class="line">右外连接</span><br><span class="line">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON条件...;</span><br><span class="line"></span><br><span class="line">连接查询-自连接</span><br><span class="line">自连接查询语法：</span><br><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件。。;</span><br><span class="line">自连接查询，可以是内连接查询，</span><br><span class="line">也可以是外连接查询。</span><br><span class="line"></span><br><span class="line">联合查询-union(去重),union all</span><br><span class="line">对于uion查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</span><br><span class="line">SELECT 字段列表 FROM 表A;</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表Bi;</span><br><span class="line"></span><br><span class="line">子查询</span><br><span class="line">●概念：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</span><br><span class="line">SELECT FROM t1 WHERE column1 (SELECT column1 FROM t2);</span><br><span class="line">子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT的任何一个。</span><br><span class="line">根据子查询结果不同，分为：</span><br><span class="line">标量子查询（子查询结果为个值）</span><br><span class="line">列子查询（子查询结果为一列</span><br><span class="line">行子查询（子查询结果为一行）</span><br><span class="line">表子查询（子查询结果为多行多列</span><br><span class="line">根据子查询位置，分为：WHERE之后、FROM之后、SELECT之后。</span><br><span class="line"></span><br><span class="line">列子查询</span><br><span class="line">子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</span><br><span class="line">常用的操作符：IN、NOT IN、ANY、SOME、ALL</span><br><span class="line">操作符									描述</span><br><span class="line">IN									在指定的集合范围之内，多选一</span><br><span class="line">NOT IN								不在指定的集合范围之内</span><br><span class="line">ANY									子查询返回列表中，有任意一个满足即可</span><br><span class="line">SOME								与ANY等同，使用SOME的地方都可以使用ANY</span><br><span class="line">ALL									子查询返回列表的所有值都必须满足</span><br><span class="line"></span><br><span class="line">行子查询</span><br><span class="line">子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</span><br><span class="line">常用的操作符：=、&lt;&gt;、N、NOT IN</span><br><span class="line"></span><br><span class="line">表子查询</span><br><span class="line">子查询返回的结果是多行多列，这种子查询称为表子查询。</span><br><span class="line">常用的操作符：IN</span><br></pre></td></tr></table></figure>

<h4 id="六-事务"><a href="#六-事务" class="headerlink" title="六.事务"></a>六.事务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</span><br><span class="line"></span><br><span class="line">查看/设置事务提交方式</span><br><span class="line">SELECT @@autocommit</span><br><span class="line">SET @@autocommit =0;</span><br><span class="line">提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">回滚事务</span><br><span class="line">ROLLBACK</span><br><span class="line"></span><br><span class="line">事务操作</span><br><span class="line">开启事务</span><br><span class="line">START TRANSACTIONBEGIN</span><br><span class="line">提交事务</span><br><span class="line">COMMIT</span><br><span class="line">回滚事务</span><br><span class="line">ROLLBACK</span><br><span class="line"></span><br><span class="line">事务特性</span><br><span class="line">原子性(Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class="line">一致性(Consistency):事务完成时，必须使所有的数据都保持一致状态。</span><br><span class="line">隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</span><br><span class="line">持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</span><br><span class="line"></span><br><span class="line">并发事务问题</span><br><span class="line">问题												描述</span><br><span class="line">脏读									一个事务读到另外一个事务还没有提交的数据。</span><br><span class="line">不可重复读				一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span><br><span class="line">幻读								一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">隔离级别						赃读			不可重复读			幻读</span><br><span class="line">Read uncommitted				√				√				√</span><br><span class="line">Read committed					×				√				√</span><br><span class="line">Repeatable Read（默认）			  ×				 ×				  √</span><br><span class="line">Serializable					×				×				×</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看事务隔离级别</span><br><span class="line">SELECT @@TRANSACTION ISOLATION;</span><br><span class="line">-设置事务隔离级别</span><br><span class="line">SET SESSION [GLOBAL TRANSACTION] ISOLATION LEVEL &#123;READ UNCOMMITTED / READ COMMITTED / REPEATABLE READ / SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h3><h4 id="一-存储引擎"><a href="#一-存储引擎" class="headerlink" title="一.存储引擎"></a>一.存储引擎</h4><p><img src="/2022/10/09/mysql/Snipaste_2022-10-11_19-36-28.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-11_19-59-24.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-11_20-08-48.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySOL体系结构</span><br><span class="line">。连接层</span><br><span class="line">最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户</span><br><span class="line">端验证它所具有的操作权限。</span><br><span class="line">服务层</span><br><span class="line">第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存</span><br><span class="line">储引擎的功能也在这一层实现，如过程、函数等。</span><br><span class="line">引擎层</span><br><span class="line">存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我</span><br><span class="line">们可以根据自己的需要，来选取合适的存储引擎。</span><br><span class="line">·存储层</span><br><span class="line">主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</span><br><span class="line"></span><br><span class="line">存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被</span><br><span class="line">称为表类型。</span><br><span class="line"></span><br><span class="line">show engines;           查看支持的引擎</span><br><span class="line"></span><br><span class="line">engine = innodb;        在建表语句后加上以指定特定的存储引擎</span><br><span class="line"></span><br><span class="line">●InnoDB</span><br><span class="line">介绍</span><br><span class="line">InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。</span><br><span class="line">特点</span><br><span class="line">DML操作遵循ACID模型，支持事务；</span><br><span class="line">行级锁，提高并发访问性能；</span><br><span class="line">支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</span><br><span class="line">文件</span><br><span class="line">XXX.ibd:xx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引。</span><br><span class="line">参数：innodb_file_per_table     show variables like &#x27;innodb_file_per_table&#x27; 默认开启表示每张表的存储引擎不共用</span><br><span class="line">ibd2sdi table.adb         命令行指令查看ibd中的sdi</span><br><span class="line"></span><br><span class="line">●MyISAM</span><br><span class="line">介绍</span><br><span class="line">MyISAM是MySQL早期的默认存储引擎。</span><br><span class="line">特点</span><br><span class="line">不支持事务，不支持外键</span><br><span class="line">支持表锁，不支持行锁</span><br><span class="line">访问速度快</span><br><span class="line">文件</span><br><span class="line">XXx.Sdi:存储表结构信息</span><br><span class="line">XXX.MYD:存储数据</span><br><span class="line">XXX.MYI:存储索引</span><br><span class="line"></span><br><span class="line">Memory</span><br><span class="line">介绍</span><br><span class="line">Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</span><br><span class="line">特点</span><br><span class="line">内存存放</span><br><span class="line">hash索引（默认）</span><br><span class="line">文件</span><br><span class="line">XX.sdi:：存储表结构信息</span><br><span class="line"></span><br><span class="line">在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组</span><br><span class="line">合。</span><br><span class="line">&gt;InnoDB:是Mysq的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致</span><br><span class="line">性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDBi存储引擎是比较合适的选择。</span><br><span class="line">&gt;MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那</span><br><span class="line">么选择这个存储引擎是非常合适的。</span><br><span class="line">&gt;MEMORY:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表</span><br><span class="line">无法缓存在内存中，而且无法保障数据的安全性。</span><br></pre></td></tr></table></figure>

<h4 id="二-索引"><a href="#二-索引" class="headerlink" title="二.索引"></a>二.索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1·介绍</span><br><span class="line">索引(1ndex)是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些</span><br><span class="line">数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</span><br><span class="line"></span><br><span class="line">优缺点       </span><br><span class="line"> 				优势											劣势</span><br><span class="line">提高数据检索的效率，降低数据库的I/O成本						索引列也是要占用空间的。</span><br><span class="line">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗		索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行															INSERT、UPDATE、DELETE时，效率降低。</span><br><span class="line"></span><br><span class="line">2.MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</span><br><span class="line">索引结												描述</span><br><span class="line">B+Tree索引						最常见的索引类型，大部分引擎都支持B+树索引</span><br><span class="line">Hash索引				底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效不支持范围查询</span><br><span class="line">R-tree（空间索引）		空间索引是ySAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</span><br><span class="line">Ful-text（全文索引）		是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,ES</span><br><span class="line"></span><br><span class="line">索引        INNODB      MYISAM      MEMORY</span><br><span class="line">B+Tree索引	支持		支持			支持</span><br><span class="line">Hash索引		不支持		不支持			支持</span><br><span class="line">R-tree		不支持		  支持		不支持</span><br><span class="line">Ful-text	5.6后支持	  支持		不支持</span><br><span class="line"></span><br><span class="line">3.索引分类						</span><br><span class="line">分类							含义					特点					关键字</span><br><span class="line">主键索引				针对于表中主键创建的索引	默认自动创建，只能有一个	PRIMARY</span><br><span class="line">唯一索引			避免同一个表中某数据列中的值重复		可以有多个			UNIQUEa</span><br><span class="line">常规索引				快速定位特定数据					可以有案个		</span><br><span class="line">全文索引	全文索引查找的是文本中的关键词，而不是比较索引中的值	可以有多个		FULLTEXT</span><br><span class="line"></span><br><span class="line">4.索引语法</span><br><span class="line">。创建索引</span><br><span class="line">CREATE [UNIQUE] [FULLTEXT] INDEX index_name ON table_name (index_col_name,...);</span><br><span class="line">·查看索引</span><br><span class="line">SHOW INDEX FROM table_name;</span><br><span class="line">●删除索引</span><br><span class="line">DROP INDEX index name ON table name;</span><br><span class="line"></span><br><span class="line">5.SQL性能分析</span><br><span class="line">SQL执行频率</span><br><span class="line">MySQL客户端连接成功后，通过show[session|global]status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</span><br><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;  七个_</span><br><span class="line"></span><br><span class="line">●慢查询日志</span><br><span class="line">慢查询日志记录了所有执行时间超过指定参数(long_query_.time,单位：秒，默认10秒)的所有SQL语句的日志。</span><br><span class="line">show variables like &#x27;slow_query_log&#x27;  查看状态 </span><br><span class="line">MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息：</span><br><span class="line">#开启MySOL慢日志查询开关</span><br><span class="line">slow_query_log=1</span><br><span class="line">#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long query time=2</span><br><span class="line">配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息var/lib/mysql/localhost-slow.log.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">profile详情</span><br><span class="line">show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have profiling参数，能够看到当前MySQL是否支持</span><br><span class="line">profile操作：</span><br><span class="line">SELECT @@have profiling</span><br><span class="line">SELECT @@profiling</span><br><span class="line">默认orofiling是关闭的，可以通过set语句在session/.global级别开启profiling:</span><br><span class="line">SET profiling =1;</span><br><span class="line"></span><br><span class="line">执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</span><br><span class="line">#查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line">#查看指定query id的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query query_id;</span><br><span class="line">#查看指定query id的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query query_id;</span><br><span class="line"></span><br><span class="line">explain执行计划</span><br><span class="line">EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</span><br><span class="line">语法：</span><br><span class="line">#直接在selecti语句之前加上关键字explain/desc</span><br><span class="line">EXPLAIN SELECT字段列表FROM表名WHERE条件；</span><br><span class="line"></span><br><span class="line">explain执行计划</span><br><span class="line">EXPLAIN执行计划各字段含义：</span><br><span class="line">ld</span><br><span class="line">selecti查询的序列号，表示查询中执行select-子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行</span><br><span class="line">select type</span><br><span class="line">表示SELECT的类型，常见的取值有SIMPLE(简单表，即不使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(SELECT/WHERE之后包含了子查询)等</span><br><span class="line">type</span><br><span class="line">表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all.</span><br><span class="line">possible key</span><br><span class="line">显示可能应用在这张表上的索引，一个或多个。</span><br><span class="line">Key</span><br><span class="line">实际使用的索引，如果为NULL,则没有使用索引。</span><br><span class="line">Key_len</span><br><span class="line">表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</span><br><span class="line">rows</span><br><span class="line">MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</span><br><span class="line">filtered</span><br><span class="line">表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。</span><br><span class="line"></span><br><span class="line">6.索引使用</span><br><span class="line">最左前缀法则</span><br><span class="line">如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</span><br><span class="line">·范围查询</span><br><span class="line">联合索引中，出现范围查询(&gt;，&lt;)，范围查询右侧的列索引失效</span><br><span class="line">explain select*from tb user where profession=&#x27;软件工程&#x27;and age&gt;30 and status=&#x27;o&#x27;;</span><br><span class="line">explain select*from tb_uer where profession=&#x27;软件工程&#x27;and age&gt;=30 and status=&#x27;o&#x27;;</span><br><span class="line"></span><br><span class="line">索引列运算</span><br><span class="line">不要在索引列上进行运算操作，索引将失效。</span><br><span class="line">字符串不加引号</span><br><span class="line">字符串类型字段使用时，不加引号，索引将失效。</span><br><span class="line">模糊查询</span><br><span class="line">如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</span><br><span class="line">or连接的条件</span><br><span class="line">用o分割开的条件，如果o前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</span><br><span class="line">数据分布影响</span><br><span class="line">如果MySQL评估使用索引比全表更慢，则不使用索引。</span><br><span class="line">●</span><br><span class="line">SQL提示</span><br><span class="line">SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</span><br><span class="line">use index:</span><br><span class="line">explain select*from tb user use index(索引名称)where 条件；    建议</span><br><span class="line">ignore index:</span><br><span class="line">explain select*from tb user ignore index(索引名称)where 条件&#x27;；  忽略</span><br><span class="line">force index:</span><br><span class="line">explain select*from tb user force index(索引名称)where 条件；   强制</span><br><span class="line">覆盖索引</span><br><span class="line">尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少sect*。</span><br><span class="line">●</span><br><span class="line">前缀索引</span><br><span class="line">当字段类型为字符串(varchar,text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO,影响查</span><br><span class="line">询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</span><br><span class="line">语法</span><br><span class="line">create index idx xxxx on table name(column(n));</span><br><span class="line">前缀长度</span><br><span class="line">可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，</span><br><span class="line">唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</span><br><span class="line">select count(distinct email)/count(*)from tb user</span><br><span class="line">select count(distinct substring(email,1,5))/count(*)from tb user</span><br><span class="line">·单列索引与联合索引</span><br><span class="line">单列索引：即一个索引只包含单个列。</span><br><span class="line">联合索引：即一个索引包含了多个列。</span><br><span class="line">在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</span><br><span class="line"></span><br><span class="line">索引设计原则</span><br><span class="line">1.针对于数据量较大，且查询比较频繁的表建立索引。</span><br><span class="line">2.针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</span><br><span class="line">3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</span><br><span class="line">4.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</span><br><span class="line">5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</span><br><span class="line">6.要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</span><br><span class="line">7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个</span><br><span class="line">索引最有效地用于查询。</span><br></pre></td></tr></table></figure>

<h4 id="三-mysql优化"><a href="#三-mysql优化" class="headerlink" title="三.mysql优化"></a>三.mysql优化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入数据</span><br><span class="line">insert优化</span><br><span class="line">批量插入</span><br><span class="line">Insert into tb_test values(1Tom2）.（2，cat2).(3,jerny）；</span><br><span class="line">手动提交事务</span><br><span class="line">start transaction；</span><br><span class="line">insert into tb_test values(i,Tom2）.（2,Cat）.（3,Jerny）</span><br><span class="line">insert into tb_test values(4.Tom）.(5，Cat）.（6,Jerry）；</span><br><span class="line">insert into tb_test values(7.Tom）.（8.Cat）.（9,jerry）</span><br><span class="line">commit</span><br><span class="line">主键顺序插入</span><br><span class="line">主键乱序插入： 8 1 9 21 88 2 4 5 89 5 7 3</span><br><span class="line">主键顺序插入 1 2 3 4 5 8 9 5 21 88 89</span><br><span class="line">大批量插入数据</span><br><span class="line">如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的oad指令进行插入。操作如下：</span><br><span class="line">#客户端连接服务端时，加上参数-loca-infile</span><br><span class="line">mysql--local-infile -u root -p</span><br><span class="line">#设置全局参数local infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local infile =1;</span><br><span class="line">#执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27;into table tb_user&#x27;fields terminated by &#x27;,lines terminated by &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">主键优化</span><br><span class="line">·数据组织方式</span><br><span class="line">在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</span><br><span class="line">页分裂</span><br><span class="line">页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据多大，会行溢出)，根据主键排列。</span><br><span class="line">·页合并</span><br><span class="line">当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。</span><br><span class="line">当页中删除的记录达到MERGE THRESHOLD(默认为页的50%),InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优</span><br><span class="line">化空间使用。</span><br><span class="line">主键设计原则</span><br><span class="line">满足业务需求的情况下，尽量降低主键的长度。</span><br><span class="line">插入数据时，尽量选择顺序插入，选择使用AUTO INCREMENT自增主键。</span><br><span class="line">尽量不要使用UUD做主键或者是其他自然主键，如身份证号。</span><br><span class="line">业务操作时，避免对主键的修改。</span><br><span class="line"></span><br><span class="line">order by优化</span><br><span class="line">①.Using filesort:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直</span><br><span class="line">接返回排序结果的排序都叫FileSort排序。</span><br><span class="line">②.Using index:通过有序索引顺序扫描直接返回有序数据，这种情况即为using index,.不需要额外排序，操作效率高。</span><br><span class="line">#没有创建索引时，根据age,phone进行排序</span><br><span class="line">explain select id,age,phone from tb_user order by age,phone;</span><br><span class="line">#创建索引</span><br><span class="line">create index idx user age phone aa on tb user(age,phone);</span><br><span class="line">#创建索引后，根据age,phone进行升序排序</span><br><span class="line">explain select id,age,phone from tb_user order by age,phone;</span><br><span class="line">#创建索引后，根据age,phonei进行降序排序</span><br><span class="line">explain select id,age,phone from tb user order by age desc,phone desc</span><br><span class="line">#根据age,phone进行降序一个升序，一个降序</span><br><span class="line">explain select id,age,phone from tb_user order by age asc,phone desc;</span><br><span class="line">#创建索引</span><br><span class="line">create index idx user age phone ad on tb user(age asc ,phone desc);</span><br><span class="line">#根据age,phone进行降序一个升序，一个降序</span><br><span class="line">explain select id,age,phone from tb user order by age asc,phone desc;</span><br><span class="line"></span><br><span class="line">&gt;根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</span><br><span class="line">&gt;尽量使用覆盖索引。</span><br><span class="line">&gt;多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC).</span><br><span class="line">&gt;如果不可避免的出现filesort,大数据量排序时，可以适当增大排序缓冲区大小sort buffer size(默认256k)。</span><br><span class="line"></span><br><span class="line">group by 优化`</span><br><span class="line">&gt;在分组操作时，可以通过索引来提高效率</span><br><span class="line">&gt;分组操作时，索引的使用也是满足最左前缀法则的。</span><br><span class="line"></span><br><span class="line">imit优化</span><br><span class="line">一个常见又非常头疼的问题就是imit2000000,10,此时需要M小ySQL排序前2000010记录，仅仅返回2000000-2000010</span><br><span class="line">的记录，其他记录丢弃，查询排序的代价非常大。</span><br><span class="line">优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</span><br><span class="line"></span><br><span class="line">count优化</span><br><span class="line">●&gt;MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</span><br><span class="line">&gt;InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</span><br><span class="line">count的几种用法</span><br><span class="line">cout()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL,累计值就加1，否则不加，最后返回累计值。</span><br><span class="line">count（主键）</span><br><span class="line">InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为u).</span><br><span class="line">count（字段）</span><br><span class="line">没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为nu,不为nul,计数累加。</span><br><span class="line">有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</span><br><span class="line">count (1)</span><br><span class="line">InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字&quot;1”进去，直接按行进行累加。</span><br><span class="line">count (*</span><br><span class="line">IoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</span><br><span class="line">按照效率排序的话，count（字段）&lt;count(主键id)&lt;count(1)≈count(*),所以尽量使用count(*)。</span><br><span class="line"></span><br><span class="line">update优化</span><br><span class="line">InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</span><br></pre></td></tr></table></figure>

<h4 id="三-视图-存储过程-触发器"><a href="#三-视图-存储过程-触发器" class="headerlink" title="三.视图/存储过程/触发器"></a>三.视图/存储过程/触发器</h4><h5 id="1-视图"><a href="#1-视图" class="headerlink" title="1.视图"></a>1.视图</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">视图</span><br><span class="line">创建</span><br><span class="line">CREATE[OR REPLACE]VIEW视图名称（列名列表）AS SELECT语句[WITH[CASCADED I LOCAL] CHECK OPTION]</span><br><span class="line">查询</span><br><span class="line">查看创建视图语句：SHOW CREATE VIEW视图名称；</span><br><span class="line">查看视图数据：SELECT*FROM视图名称…；</span><br><span class="line">修改R</span><br><span class="line">方式一：CREATE[OR REPLACE]VIEW视图名称[（列名列表）]AS SELECTi语句[WITH[CASCADED|LOCAL]CHECK OPTION]</span><br><span class="line">方式二：ALTER VIEW视图名称（列名列表）】AS SELECTi语句[WITH[CASCADED|LOCAL]CHECK OPTION]</span><br><span class="line">删除</span><br><span class="line">DROP VIEW[IF EXISTS]视图名称[，视图名称]....</span><br><span class="line">·视图的检查选项</span><br><span class="line">当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定</span><br><span class="line">义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，ysql提供了两个选项：</span><br><span class="line">CASCADED和LOCAL,默认值为CASCADED。</span><br><span class="line">CASCADED会检查所有依赖的视图的条件</span><br><span class="line">local 检查不检查条件取决于依赖的视图是否定义了条件</span><br><span class="line"></span><br><span class="line">。视图的更新</span><br><span class="line">要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</span><br><span class="line">1.聚合函数或窗口函数(SUM()、MIN()、MAX、COUNT()等)</span><br><span class="line">2.DISTINCT</span><br><span class="line">3.GROUP BY</span><br><span class="line">4.HAVING</span><br><span class="line">5.UNION或者UNION ALL</span><br><span class="line">●</span><br><span class="line">作用</span><br><span class="line">简单</span><br><span class="line">视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作</span><br><span class="line">每次指定全部的条件。</span><br><span class="line">安全</span><br><span class="line">数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</span><br><span class="line">数据独立</span><br><span class="line">视图可帮助用户屏蔽真实表结构变化带来的影响。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2.存储过程"></a>2.存储过程</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储过程</span><br><span class="line">·介绍</span><br><span class="line">存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据</span><br><span class="line">库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</span><br><span class="line">存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</span><br><span class="line">特点</span><br><span class="line">封装，复用</span><br><span class="line">可以接收参数，也可以返回数据</span><br><span class="line">减少网络交互，效率提升</span><br><span class="line"></span><br><span class="line">创建</span><br><span class="line">CREATE PROCEDURE存储过程名称(I参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">-SQL语句</span><br><span class="line">END;</span><br><span class="line">调用</span><br><span class="line">CALL名称(【参数】)：</span><br><span class="line">查看</span><br><span class="line">SELECT*FROM INFORMATION SCHEMA.ROUTINES WHERE ROUTINE SCHEMA=&#x27;Xx&#x27;;-查询指定数据库的存储过程及状态信息</span><br><span class="line">SHOW CREATE PROCEDURE存储过程名称；-查询某个存储过程的定义</span><br><span class="line">删除</span><br><span class="line">DROP PROCEDURE[IF EXISTS]存储过程名称；</span><br><span class="line">注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。</span><br><span class="line"></span><br><span class="line">变量</span><br><span class="line">系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION).</span><br><span class="line">查看系统变量</span><br><span class="line">SHOW [SESSION] [GLOBAL] VARIABLES</span><br><span class="line">-查看所有系统变量</span><br><span class="line">SHOW[SESSION][ GLOBAL]VARIABLES LIKE&#x27;;一可以通过LIKE模糊匹配方式查找变量</span><br><span class="line">SELECT@@[SESSION|GLOBAL]系统变量名：</span><br><span class="line">查看指定变量的值</span><br><span class="line">设置系统变量</span><br><span class="line">SET[SESSION I GLOBAL]系统变量名=值；</span><br><span class="line">SET@@[SESSION|GLOBAL]系统变量名=值：</span><br><span class="line">注意：</span><br><span class="line">如果没有指定SESSION/GLOBAL,默认是SESSION,会话变量。</span><br><span class="line">mysq服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cn中配置</span><br><span class="line"></span><br><span class="line">·变量</span><br><span class="line">用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。</span><br><span class="line">&gt;赋值</span><br><span class="line">SET @var name=expr [@var_name expr]...;</span><br><span class="line">SET @var name:=expr [@var name:=expr]...;</span><br><span class="line">SELECT @var name :=expr [@var name:=expr]...;</span><br><span class="line">SELECT字段名INTO@var name FROM表名;</span><br><span class="line">使用</span><br><span class="line">SELECT @var name;</span><br><span class="line"></span><br><span class="line">局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量</span><br><span class="line">的范围是在其内声明的BEGIN.END块。</span><br><span class="line">声明</span><br><span class="line">DECLARE变量名 变量类型 [DEFAULT];</span><br><span class="line">变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</span><br><span class="line">赋值</span><br><span class="line">SET变量名=值；</span><br><span class="line">SET变量名：=值；</span><br><span class="line">SELECT字段名INTO变量名FROM表名；</span><br><span class="line"></span><br><span class="line">。if</span><br><span class="line">语法：</span><br><span class="line">IF条件1THEN</span><br><span class="line">ELSEIF条件2 THEN    -可选</span><br><span class="line">ELSE               -可选</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">·参数</span><br><span class="line">类型                 含义                     备注</span><br><span class="line">IN    该类参数作为输入，也就是需要调用时传入值      默认</span><br><span class="line">ouT  该类参数作为输出，也就是该参数可以作为返回值</span><br><span class="line">INOUT  既可以作为输入参数，也可以作为输出参数</span><br><span class="line"></span><br><span class="line">case</span><br><span class="line">语法一</span><br><span class="line">CASE case value</span><br><span class="line">[WHEN when value1 THEN statement list1]</span><br><span class="line">[WHEN when value2 THEN statement list 2]...</span><br><span class="line">[ELSE statement list]</span><br><span class="line">END CASE;</span><br><span class="line"></span><br><span class="line">语法二</span><br><span class="line">CASE</span><br><span class="line">WHEN search condition1 THEN statement list1....</span><br><span class="line">[WHEN search condition2 THEN statement list2]...</span><br><span class="line">[ELSE statement list]</span><br><span class="line">END CASE;</span><br><span class="line"></span><br><span class="line">while</span><br><span class="line">while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</span><br><span class="line">#先判定条件，如果条件为tue,则执行逻辑，否则，不执行逻辑</span><br><span class="line">WHILE条件DO</span><br><span class="line">SQL逻辑</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line">repeat是有条件的循环控制语句，当满足条件的时候退出循环。具体语法为：</span><br><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">SQL逻辑...</span><br><span class="line">UNTIL条件</span><br><span class="line">END REPEAT;</span><br><span class="line"></span><br><span class="line">loop</span><br><span class="line">LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用：</span><br><span class="line">LEAVE:配合循环使用，退出循环。</span><br><span class="line">TERATE:必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</span><br><span class="line">begin label:LOOP</span><br><span class="line">SQL逻辑...</span><br><span class="line">END LOOP [end label];</span><br><span class="line">LEAVE label;-退出指定标记的循环体</span><br><span class="line">TERATE label;-直接进入下一次循环</span><br><span class="line"></span><br><span class="line">·游标</span><br><span class="line">游标(CUSO)是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标</span><br><span class="line">的声明、OPEN、FETCH和CLOSE,其语法分别如下。</span><br><span class="line">&gt;声明游标</span><br><span class="line">DECLARE游标名称CURSOR FOR查询语句；</span><br><span class="line">&gt;打开游标</span><br><span class="line">OPEN游标名称；</span><br><span class="line">&gt;获取游标记录</span><br><span class="line">FETCH游标名称INTO变量【变量】；</span><br><span class="line">&gt;关闭游标</span><br><span class="line">CLOSE游标名称；</span><br><span class="line"></span><br><span class="line">条件处理程序</span><br><span class="line">条件处理程序(Handler)可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</span><br><span class="line">DECLARE handler action HANDLER FOR condition value [condition value]...statement</span><br><span class="line">handler action</span><br><span class="line">CONTINUE:继续执行当前程序</span><br><span class="line">EXIT:终止执行当前程序</span><br><span class="line">condition_value</span><br><span class="line">SQLSTATE sqlstate value:状态码，如02000</span><br><span class="line">SQLWARNING:所有以01开头的SQLSTATE代码的简写</span><br><span class="line">NOT FOUND:所有以O2开头的SOLSTATE代码的简写</span><br><span class="line">SQLEXCEPTION:所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写</span><br><span class="line"></span><br><span class="line">存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</span><br><span class="line">CREATE FUNCTION存储函数名称(L参数列表])</span><br><span class="line">RETURNS type [characteristic]</span><br><span class="line">BEGIN</span><br><span class="line">-</span><br><span class="line">SQL语句</span><br><span class="line">RETURN ...</span><br><span class="line">END;</span><br><span class="line">characteristici说明：</span><br><span class="line">DETERMINISTIC:相同的输入参数总是产生相同的结果</span><br><span class="line">NO SQL:不包含SQL语句。</span><br><span class="line">READS SQL DATA:包含读取数据的语句，但不包含写入数据的语句。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3.触发器"></a>3.触发器</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">触发器</span><br><span class="line">·介绍</span><br><span class="line">触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作</span><br><span class="line">使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发</span><br><span class="line"></span><br><span class="line">触发器类型                                              NEW和OLD</span><br><span class="line">INSERT型触发器                             NEW表示将要或者已经新增的数据</span><br><span class="line">UPDATE型触发器             OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</span><br><span class="line">DELETE3型触发器                                    OLD表示将要或者已经删除的数据</span><br><span class="line"></span><br><span class="line">·语法</span><br><span class="line">&gt;创建</span><br><span class="line">CREATE TRIGGER trigger_name</span><br><span class="line">BEFORE/AFTER INSERT/UPDATE/DELETE</span><br><span class="line">ON tbl name FOR EACH ROW-行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">trigger_stmt;</span><br><span class="line">END;</span><br><span class="line">&gt;</span><br><span class="line">查看</span><br><span class="line">SHOW TRIGGERS</span><br><span class="line">&gt;</span><br><span class="line">删除</span><br><span class="line">DROP TRIGGER[schema name.]trigger name;-如果没有指定schema name,默认为当前数据库。</span><br></pre></td></tr></table></figure>

<h4 id="四-锁"><a href="#四-锁" class="headerlink" title="四.锁"></a>四.锁</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、1/0）的争用以外，数据也是</span><br><span class="line">一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访</span><br><span class="line">问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MySQL中的锁，按照锁的粒度分，分为以下三类：</span><br><span class="line">1.全局锁：锁定数据库中的所有表。</span><br><span class="line">2.表级锁：每次操作锁住整张表。</span><br><span class="line">3.行级锁：每次操作锁住对应的行数据。</span><br></pre></td></tr></table></figure>

<h5 id="3-全局锁"><a href="#3-全局锁" class="headerlink" title="3.全局锁"></a>3.全局锁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局锁</span><br><span class="line">介绍</span><br><span class="line">全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都</span><br><span class="line">将被阻塞</span><br><span class="line">其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性</span><br><span class="line">语法:</span><br><span class="line">flush tables with read lock;                                  锁</span><br><span class="line">mysqldump -Uroot -P密码 数据库名&gt;数据库名.sql              备份   在命令行中执行</span><br><span class="line">unlock tables;                                          解锁</span><br><span class="line"></span><br><span class="line">●特点</span><br><span class="line">数据库中加全局锁，是一个比较重的操作，存在以下问题：</span><br><span class="line">1.如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</span><br><span class="line">2.如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog),会导致主从延迟。</span><br><span class="line">在InnoDB引擎中，我们可以在备份时加上参数-single-transaction参数来完成不加锁的一致性数据备份。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-表级锁"><a href="#4-表级锁" class="headerlink" title="4.表级锁"></a>4.表级锁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表级锁</span><br><span class="line">·介绍</span><br><span class="line">表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</span><br><span class="line">对于表级锁，主要分为以下三类：</span><br><span class="line">1.表锁</span><br><span class="line">2.元数据锁(meta data lock,MDL)</span><br><span class="line">3.意向锁</span><br><span class="line">●表锁</span><br><span class="line">对于表锁，分为两类：</span><br><span class="line">1.表共享读锁(read lock)                      每个客户端都只能读不能写</span><br><span class="line">2.表独占写锁(write lock)                     当前客户端可以读写其他客户端不能读写</span><br><span class="line">语法：</span><br><span class="line">1.加锁：lock tables表名。read/write.</span><br><span class="line">2.释放锁：unlock tables/客户端断开连接。</span><br><span class="line">●元数据锁(meta data lock,MDL)</span><br><span class="line">MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表</span><br><span class="line">上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</span><br><span class="line">在MySQL5.5中引入了MDL,当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）。</span><br><span class="line"></span><br><span class="line">查看元数据锁：</span><br><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from performance _schema.metadata_locks;</span><br><span class="line">●意向锁</span><br><span class="line">为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减</span><br><span class="line">少耒锁的检杳</span><br><span class="line">1.意向共享锁(IS).:由语句select....lock in share mode添加。</span><br><span class="line">2.意向排他锁(IX):由insert、update、delete、select....for update添加。</span><br><span class="line">1.意向共享锁(IS):与表锁共享锁(read)兼容，与表锁排它锁(write)互斥。</span><br><span class="line">2.意向排他锁(IX):与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥。</span><br><span class="line">可以通过以下SQL,查看意向锁及行锁的加锁情况：</span><br><span class="line">select_object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance _schema.data_locks;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-14_17-22-32.png"></p>
<h5 id="5-行级锁"><a href="#5-行级锁" class="headerlink" title="5.行级锁"></a>5.行级锁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">行级锁</span><br><span class="line">·介绍</span><br><span class="line">行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</span><br><span class="line">innoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</span><br><span class="line">I.行锁(Record Lock):锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</span><br><span class="line">2.间隙锁(Gap Lock)：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert,产生幻读。在RR隔离级别下都支持。</span><br><span class="line">3.临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</span><br><span class="line">●行锁</span><br><span class="line">InnoDB实现了以下两种类型的行锁：</span><br><span class="line">1.共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</span><br><span class="line">2.排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</span><br><span class="line">●行锁-演示</span><br><span class="line">默认情况下，InnoDB在REPEATABLE READ:事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</span><br><span class="line">1.针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</span><br><span class="line">2.InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-14_17-44-21.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-14_17-44-53.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">●间隙锁/临键锁-演示</span><br><span class="line">默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</span><br><span class="line">1.索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</span><br><span class="line">2.索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</span><br><span class="line">3.索引上的范围查询（唯一索引）--会访问到不满足条件的第一个值为止。</span><br><span class="line">注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</span><br></pre></td></tr></table></figure>

<h4 id="五-innodb引擎"><a href="#五-innodb引擎" class="headerlink" title="五.innodb引擎"></a>五.innodb引擎</h4><h5 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-11_19-59-24.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表空间(ibd文件)，一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</span><br><span class="line">段，分为数据段(Leaf node segment)、索引段(Non-leaf node segment)、回滚段(Rollback segment),InnoDB</span><br><span class="line">是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</span><br><span class="line">区，表空间的单元结构，每个区的大小为1M。默认情况下，innoDB存储引擎页大小</span><br><span class="line">为16K,即一个区中一共有64个连续的页。</span><br><span class="line">页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。</span><br><span class="line">行，InnoDB存储引擎数据是按行进行存放的。</span><br><span class="line">Trxid:每次对某条记录进行改动时，都会把对应的事务id赋值给trxid隐藏列。</span><br><span class="line">Roll pointer:每次对某条引记录进行改动时，都会把I旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_10-47-15.png"></p>
<h5 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">分为内存架构和磁盘架构两部分</span><br><span class="line"></span><br><span class="line">内存架构</span><br><span class="line">Bufer Pool:缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改</span><br><span class="line">查操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，然后再以一定频率刷</span><br><span class="line">新到磁盘，从而减少磁盘IO,加快处理速度。</span><br><span class="line">缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</span><br><span class="line">·free page:空闲page,未被使用。</span><br><span class="line">·clean page:被使用page,数据没有被修改过。</span><br><span class="line">dirty page:脏页，被使用page,数据被修改过，也中数据与磁盘的数据产生了不一致。</span><br><span class="line"></span><br><span class="line">Change Buffer:更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page</span><br><span class="line">没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未</span><br><span class="line">来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</span><br><span class="line">Change Buffert的意义是什么？</span><br><span class="line">与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更</span><br><span class="line">新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了</span><br><span class="line">ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</span><br><span class="line"></span><br><span class="line">Adaptive Hash Index:自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监</span><br><span class="line">控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash</span><br><span class="line">索引。</span><br><span class="line">自适应哈希索引，无需人工干预，是系统根据情况自动完成。</span><br><span class="line">参数：adaptive_hash_index</span><br><span class="line"></span><br><span class="line">Log Buffer:日志缓冲区，用来保存要写入到磁盘中的og日志数据(redo log、undo log),默认大</span><br><span class="line">小为16MB,日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加</span><br><span class="line">日志缓冲区的大小可以节省磁盘I/O.</span><br><span class="line">参数：</span><br><span class="line">innodb_log_buffer_size:缓冲区大小</span><br><span class="line">innodb_flush._log_at_trx_commit:日志刷新到磁盘时机</span><br><span class="line">1:日志在每次事务提交时写入并刷新到磁盘</span><br><span class="line">0:每秒将日志写入并刷新到磁盘一次。</span><br><span class="line">2:日志在每次事务提交后写入，并每秒刷新到磁盘一次。</span><br><span class="line"></span><br><span class="line">磁盘架构</span><br><span class="line">System Tablespace:系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表</span><br><span class="line">文件或通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数</span><br><span class="line">据字典、undolog等）</span><br><span class="line">参数：innodb_data_fle_path</span><br><span class="line">File-Per-Table Tablespaces:每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在</span><br><span class="line">文件系统上的单个数据文件中。</span><br><span class="line">参数：innodb_file_per_table</span><br><span class="line">General Tablespaces:通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可</span><br><span class="line">以指定该表空间。</span><br><span class="line">语法</span><br><span class="line">CREATE TABLESPACE XXXX ADD</span><br><span class="line">DATAFILE &#x27;file_name&#x27;</span><br><span class="line">ENGINE= engine_name;</span><br><span class="line">CREATE TABLE xxx...TABLESPACE ts_name;</span><br><span class="line">Undo Tablespaces:撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小</span><br><span class="line">16M),用于存储undo log日志。</span><br><span class="line">Temporary Tablespaces:InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</span><br><span class="line">Doublewrite Buffer Files:双写缓冲区，innoDB引擎将数据页从Buffer PoolF刷新到磁盘前，先</span><br><span class="line">将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</span><br><span class="line">Redo Log:重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲</span><br><span class="line">(redo log buffer)以及重做日志文件(redo log),前者是在内存中，后者在磁盘中。当事务提</span><br><span class="line">交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复</span><br><span class="line">使用。</span><br></pre></td></tr></table></figure>

<h5 id="3-事务原理"><a href="#3-事务原理" class="headerlink" title="3.事务原理"></a>3.事务原理</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.redo log  解决事务持久性</span><br><span class="line">重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</span><br><span class="line">该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log file),前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</span><br><span class="line">2.undo log  解决事务原子性</span><br><span class="line">回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。</span><br><span class="line">undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的inserti记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</span><br><span class="line">Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log,因为这些日志可能还用于MVCC.</span><br><span class="line">Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</span><br><span class="line"></span><br><span class="line">redo log +undo log  解决事务一致性</span><br><span class="line">锁+mvcc                解决事务隔离性</span><br></pre></td></tr></table></figure>

<h5 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.基本概念</span><br><span class="line">当前读</span><br><span class="line">读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</span><br><span class="line">select...lock in share mode（共享锁），select.for update、update、insert、delete（排他锁）都是一种当前读。</span><br><span class="line">快照读</span><br><span class="line">简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</span><br><span class="line">Read Committed:每次select,,都生成一个快照读。</span><br><span class="line">Repeatable Read: 开启事务后第一个select语句才是快照读</span><br><span class="line">Serializable:快照读会退化为当前读。</span><br><span class="line">MVCC</span><br><span class="line">全称Multi--Version Concurrency Control,多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</span><br><span class="line"></span><br><span class="line">2.隐式字段</span><br><span class="line">隐藏字段                                               含义</span><br><span class="line">DB_TRX_ID     最近修改事务ID,记录插入这条记录或最后一次修改该记录的事务ID.</span><br><span class="line">DB_ROL_PTR  回滚指针，指向这条记录的上一个版本，用于配合undo log,指向上一个版本。</span><br><span class="line">DB ROW ID    隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</span><br><span class="line"></span><br><span class="line">3.undo log</span><br><span class="line">回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</span><br><span class="line">当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即副除。</span><br><span class="line">而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</span><br><span class="line">undo log 版本链</span><br><span class="line"></span><br><span class="line">ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id.</span><br><span class="line">ReadView中包含了四个核心字段：</span><br></pre></td></tr></table></figure>



<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_13-44-33.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_13-44-51.png"></p>
<h5 id="5-系统数据库"><a href="#5-系统数据库" class="headerlink" title="5.系统数据库"></a>5.系统数据库</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_13-59-55.png"></p>
<h5 id="6-常用工具"><a href="#6-常用工具" class="headerlink" title="6.常用工具"></a>6.常用工具</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_14-03-29.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_14-06-37.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_14-07-32.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_14-09-04.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_14-11-49.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_14-16-25.png"></p>
<h3 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a>运维篇</h3><h4 id="一-日志"><a href="#一-日志" class="headerlink" title="一.日志"></a>一.日志</h4><h5 id="1-错误日志"><a href="#1-错误日志" class="headerlink" title="1.错误日志"></a>1.错误日志</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">错误日志是MySQL中最重要的日志之一，它记录了当ysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息</span><br><span class="line">。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</span><br><span class="line">该日志是默认开启的，默认存放目录var/log/,默认的日志文件名为mysqld.log。查看日志位置：</span><br><span class="line">show variables like &#x27;%log_error%&#x27;</span><br></pre></td></tr></table></figure>



<h5 id="2-二进制日志"><a href="#2-二进制日志" class="headerlink" title="2.二进制日志"></a>2.二进制日志</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二进制日志(BINLOG)记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询(SELECT、SHOW)</span><br><span class="line">语句。</span><br><span class="line">作用：①.灾难时的数椐恢复；②.MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下：</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;</span><br><span class="line"></span><br><span class="line">MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-27-43.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志查看</span><br><span class="line">由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看.</span><br><span class="line"></span><br><span class="line">日志删除</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-32-33.png"></p>
<h5 id="3-查询日志"><a href="#3-查询日志" class="headerlink" title="3.查询日志"></a>3.查询日志</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-35-07.png"></p>
<h5 id="4-慢查询日志"><a href="#4-慢查询日志" class="headerlink" title="4.慢查询日志"></a>4.慢查询日志</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-38-21.png"></p>
<h4 id="二-主从复制"><a href="#二-主从复制" class="headerlink" title="二.主从复制"></a>二.主从复制</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而</span><br><span class="line">使得从库和主库的数据保持同步。</span><br><span class="line">小ySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</span><br><span class="line">MySQL复制的有点主要包含以下三个方面：</span><br><span class="line">1.主库出现问题，可以快速切换到从库提供服务。</span><br><span class="line">2.实现读写分离，降低主库的访问压力。</span><br><span class="line">3.可以在从库中执行备份，以避免备份期间影响主库服务。</span><br></pre></td></tr></table></figure>



<h5 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-46-39.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从上图来看，复制分成三步：</span><br><span class="line">1.Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中。</span><br><span class="line">2.从库读取主库的二进制日志文件Binlog,写入到从库的中继日志Relay Log.</span><br><span class="line">3 slave重做中继日志中的事件，将改变反映它自己的数据</span><br></pre></td></tr></table></figure>



<h5 id="3-搭建"><a href="#3-搭建" class="headerlink" title="3.搭建"></a>3.搭建</h5><p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-53-42.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-54-08.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-54-32.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-56-19.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-57-23.png"></p>
<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_15-59-58.png"></p>
<h4 id="三-分库分表"><a href="#三-分库分表" class="headerlink" title="三.分库分表"></a>三.分库分表</h4><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</span><br><span class="line">1.IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO,效率较低。请求数据太多，带宽不够，网络IO瓶颈。</span><br><span class="line">2.CPU瓶颈：排序、分组、连接查询聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</span><br><span class="line"></span><br><span class="line">分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的，</span><br><span class="line"></span><br><span class="line">垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</span><br><span class="line">特点：</span><br><span class="line">1.每个库的表结构都不一样。</span><br><span class="line">2.每个库的数据也不一样。</span><br><span class="line">3.所有库的并集是全量数据。</span><br><span class="line">垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</span><br><span class="line">特点：</span><br><span class="line">1.每个表的结构都不一样。</span><br><span class="line">2.每个表的数据也不一样，一般通过一列(主键/外键)关联。</span><br><span class="line">3.所有表的并集是全量数据。</span><br><span class="line">水平分库：以字段为依据，按照一定策略，将一个库的数据拆</span><br><span class="line">分到多个库中。</span><br><span class="line">特点：</span><br><span class="line">1.每个库的表结构都一样。</span><br><span class="line">2.每个库的数据都不一样。</span><br><span class="line">3.所有库的并集是全量数据。</span><br><span class="line">水平分表：以字段为依据，按照一定策略，将一个表的数据拆</span><br><span class="line">分到多个表中。</span><br><span class="line">特点：</span><br><span class="line">1.每个表的表结构都一样。</span><br><span class="line">2.每个表的数据都不一样。</span><br><span class="line">3.所有库的并集是全量数据。</span><br><span class="line"></span><br><span class="line">实现方法</span><br><span class="line">●sharding]DBC:基于AOP原理，在应用程序中对本地执的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持</span><br><span class="line">java语言，性能较高。</span><br><span class="line">●MyCat:数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</span><br></pre></td></tr></table></figure>



<h5 id="2-mycat概述"><a href="#2-mycat概述" class="headerlink" title="2.mycat概述"></a>2.mycat概述</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mycat:是开源的、话跃的、基于ava语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat,对于开发人员来说根本感觉</span><br><span class="line">不到mycati的存在。</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_19-00-28.png"></p>
<h5 id="3-mycat配置"><a href="#3-mycat配置" class="headerlink" title="3.mycat配置"></a>3.mycat配置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">●schema.xml</span><br><span class="line">schema.xml作为MyCatr中最重要的配置文件之一，涵盖了MyCatE的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。</span><br><span class="line">主要包含以下三组标签：</span><br><span class="line">&gt;schema标签</span><br><span class="line">&gt;datanode标签</span><br><span class="line">&gt;datahost标签</span><br><span class="line"></span><br><span class="line">schema标签用于定义MyCat3实例中的逻辑库，一个MyCat3实例中，可以有多个逻辑库，可以通过schema标签来划分不同的逻辑库。</span><br><span class="line">MyCati中的逻辑库的概念，等同于MySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库(use xxx)。</span><br><span class="line">核心属性：</span><br><span class="line">·name:指定自定义的逻辑库库名</span><br><span class="line">checkSQLschema:在SQL语句操作时指定了数据库名称，执行时是否自动去除；true:自动去除，false:不自动去除</span><br><span class="line">sqlMaxLimit:如果未指定limt进行查询，列表查询模式查询多少条记录</span><br><span class="line">table标签定义了MyCati中逻辑库schema下的逻辑表，所有需要拆分的表都需要在table标签中定义。</span><br><span class="line">核心属性：</span><br><span class="line">name:：定义逻辑表表名，在该逻辑库下唯一</span><br><span class="line">dataNode:定义逻辑表所属的dataNode,该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</span><br><span class="line">·rule:分片规则的名字，分片规则名字是在rule.xml中定义的</span><br><span class="line">primaryKey:逻辑表对应真实表的主键</span><br><span class="line">·type:逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为global</span><br><span class="line"></span><br><span class="line">dataNode标签中定义了MyCat中的数据节点，也就是我们通常说的数据分片。一个dataNode标签就是一个独立的数据分片。</span><br><span class="line">核心属性：</span><br><span class="line">name：定义数据节点名称</span><br><span class="line">dataHost:数据库实例主机名称，引用自dataHost标签中name属性</span><br><span class="line">database:定义分片所属数据库</span><br><span class="line"></span><br><span class="line">datahost</span><br><span class="line">该标签在MyCt逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</span><br><span class="line">核心属性：</span><br><span class="line">·name:唯一标识，供上层标签使用</span><br><span class="line">maxCon/minCon:最大连接数/最小连接数</span><br><span class="line">balance:负载均衡策略，取值0,1,2,3</span><br><span class="line">writeType:写操作分发方式(O:写操作转发到第一个writeHost,第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost)</span><br><span class="line">dbDriver:数据库驱动，支持native、jdb</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rule.xml</span><br><span class="line"></span><br><span class="line">rue.x中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配</span><br><span class="line">置化。主要包含两类标签：tableRule、Function。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.xml配置文件包含了MyCatl的系统配置信息，主要有两个重要的标签：system、user。</span><br></pre></td></tr></table></figure>



<h5 id="4-mycat分片"><a href="#4-mycat分片" class="headerlink" title="4.mycat分片"></a>4.mycat分片</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过配置schema.xml rule.xml server.xml 实现分片</span><br></pre></td></tr></table></figure>



<h5 id="5-mycat管理和监控"><a href="#5-mycat管理和监控" class="headerlink" title="5.mycat管理和监控"></a>5.mycat管理和监控</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">●Mycat管理</span><br><span class="line">Mycat默认开通2个端口，可以在server.xml中进行修改。</span><br><span class="line">8066数据访问端口，即进行DML和DDL操作。</span><br><span class="line">9066数据库管理端口，即mycat服务管理控制功能，用于管理mycat的整个集群状态</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_20-03-10.png"></p>
<h4 id="四-读写分离"><a href="#四-读写分离" class="headerlink" title="四.读写分离"></a>四.读写分离</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读写分离，简单地说是把对数据库的读和写操作分开，以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效</span><br><span class="line">地减轻单台数据库的压力。</span><br><span class="line">通过MyCatl即可轻易实现上述功能，不仅可以支持MySQL,也可以支持Oracle和SQL Server。</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/09/mysql/Snipaste_2022-10-17_20-10-00.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双主双从</span><br><span class="line">·介绍</span><br><span class="line">一个主机Master1用于处理所有写请求，它的从机Slave1和另一台主机Master2还有它的从机Slave:2负责所有读请求。当Master1:</span><br><span class="line">主机宕机后，Master2主机负责写请求，Master1、Master2互为备机。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>运行命令</title>
    <url>/2022/08/15/%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="win-r"><a href="#win-r" class="headerlink" title="win + r"></a>win + r</h1><p>gpedit.msc 本地组策略编辑器</p>
<p>regedit 注册表编辑器</p>
<p>shell：文件夹   打开</p>
<p>msconfig 系统配置</p>
<p>cmd 终端</p>
<p>services.msc  本地服务</p>
]]></content>
      <categories>
        <category>windows运行</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="Hexo零基础搭建个人博客"><a href="#Hexo零基础搭建个人博客" class="headerlink" title="Hexo零基础搭建个人博客"></a>Hexo零基础搭建个人博客</h3><p>Hexo是一个基于 node.js的快速生成静态博客的开源框架,支持 Markdown和大多数 Octopress<br>插件,一个命令即可部署到 Github页面、 Giteee、 Heroku等,强大的APl,可无限扩展,拥有<br>数百个主题和插件。</p>
<h4 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h4><p>1、安装Node.js<br>直接到官网上下载安装即可<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)<br>Node自带npm<br>2、安装Git<br>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.<br>Mac：使用 Homebrew, <a href="https://www.macports.org/">MacPorts</a> 或者下载 安装程序。<br>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code><br>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1.png"></p>
<p>npm下载慢的话也可以下载淘宝下载源cnpm</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<h4 id="二、开始安装Hexo"><a href="#二、开始安装Hexo" class="headerlink" title="二、开始安装Hexo"></a>二、开始安装Hexo</h4><p>1、安装hexo(cd进入到你要创立博客的文件内)<br><code>npm install -g hexo-cli</code><br><code>或者</code><br><code>cnpm install -g hexo-cli</code><br>安装完成可输入hexo -v查看版本</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/2.png"></p>
<p>2、初始化hexo，新建存储博客的文件夹<br><code>hexo init myblog</code></p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3.png"></p>
<p>3、进入文件夹，安装一下npm<br>cd myblog<br>npm install<br>可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4.png"></p>
<p>4、启动服务站点<br><code>hexo g</code><br><code>hexo server</code></p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5.png"></p>
<p>访问<a href="http://localhost:4000/">http://localhost:4000/</a> 至此hero就搭建好了。可以在本地访问了</p>
<h4 id="三、Gitee上建站访问"><a href="#三、Gitee上建站访问" class="headerlink" title="三、Gitee上建站访问"></a>三、Gitee上建站访问</h4><p>可在github或者gitee上建站，gitee国内访问快一些</p>
<p>1、新建仓库<br>仓库名和路径格式必须是：用户名 只有这样，将来要部署到Gite e page的时候，才会被识别.</p>
<p>2、将hexo博客站点上传到gitee上<br>这里需要安装一个hexo的上传插件deploy-git</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>3、修改hexo配置文件指定仓库路径<br>可在文件夹中直接打开文件，也可通过vim直接编辑</p>
<p>找到Deployment加上（注意空格）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: 你的仓库路径</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7.png"></p>
<p>在URL中找到url地址改为<a href="https://gitee.com/XXX/XXX.git">https://gitee.com/XXX/XXX.git</a>     XXX为你的用户名</p>
<p>在url 下面添加 <code>root: ./XXX</code>     XXX为你的用户名</p>
<p>4、推送hexo站点文件<br>之后就可以推送博客站点到gitee上了</p>
<p>推送命令<br><code>hexo d</code><br>扩展：</p>
<p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p>
<p>推送中会要求输入gitee的用户名和密码（如果不想每次都输可以<a href="/2022/08/18/%E9%85%8D%E7%BD%AEssh/" title="配置ssh">配置ssh</a>，我这里就不做演示了）</p>
<p>然后就可以看到gitee上有推上来的文件了</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/8.png"></p>
<p>5、配置Pages服务<br>目前我们站点还无法访问需要开启Gitee Pages（gitee需要开启，github不需要）</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9.png"></p>
<p>审核通过启动我们就可以访问啦。</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/10.png"></p>
<p>gitee上传新文件之后，需要手动更新一下，更新后的页面才会生效</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/11.png"></p>
<p>多说一句：如果觉得这个访问路径太长了，我们可以去买一个域名，将该路径绑定到域名上，即可通过域名访问了。</p>
<h4 id="四、GitHub上建站访问"><a href="#四、GitHub上建站访问" class="headerlink" title="四、GitHub上建站访问"></a>四、GitHub上建站访问</h4><p>在gitee上建站发现有限制条件，所有也可以采用github建站的方式。</p>
<p>步骤和gitee一样。</p>
<p>1、新建guthub仓库<br>仓库名称限制了为你的：用户名+.github.io</p>
<p>2、安装hexo上传插件<br><code>npm install hexo-deployer-git --save</code><br>3、修改hexo配置文件指定仓库路径<br>可在文件夹中直接打开文件，也可通过vim直接编辑</p>
<p><code>vim _config.yml #找到Deploymentdeploy:  type: git  repo: 你的github仓库路径  branch: master</code><br><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/12.png"></p>
<p>4、推送站点到github<br><code>推送命令hexo d</code><br>推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现鉴权失败（用户名密码错误）</p>
<p>解决方式就是获取token，登录github设置setting-&gt;Developer Settings-&gt;Prosonal access tokens 创建一个新token。然后就可以拿这个token当密码输入了。用户名和token输入后，上传成功。</p>
<p>建议使用<a href="/2022/08/18/%E9%85%8D%E7%BD%AEssh/" title="配置ssh">配置ssh</a></p>
<h4 id="5、尝试访问"><a href="#5、尝试访问" class="headerlink" title="5、尝试访问"></a>5、尝试访问</h4><p>输入你的仓库名称,即可访问成功。</p>
<p><a href="https://xxx.github.io/">https://XXX.github.io/</a></p>
<h4 id="五、更换主题"><a href="#五、更换主题" class="headerlink" title="五、更换主题"></a>五、更换主题</h4><p>到GitHub上搜索hexo主题或者hero自带的主题<a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p>
<p>1、找一个喜欢的。</p>
<p>按照各自的主题文档上面一步步操作即可。</p>
<p>一般步骤：</p>
<p>1、下载解压2、放到主题包themes文件夹下面3、在hero配置文件_config.yml中修改为喜欢主题的名字4、hero server启动即可访问</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/13.png"></p>
<h4 id="六、更新仓库"><a href="#六、更新仓库" class="headerlink" title="六、更新仓库"></a>六、更新仓库</h4><p>本地调试完之后。就可以更新到github上了</p>
<p>//清理hexo clean//构建静态文件hexo g//上传至仓库hexo d</p>
<h4 id="七、写文章"><a href="#七、写文章" class="headerlink" title="七、写文章"></a>七、写文章</h4><p>在站点文件夹中打开 git ，输入hexo new 博客名称。hexo会在source文件夹下_posts的创建一个markdowm的文件。这就是你要编写的文章。</p>
<p>在上传更新到github上立马能够查看到。</p>
<p>//清理hexo clean//构建静态文件hexo g//上传至仓库(上传报错多位网络原因，多上传几次即可)hexo d</p>
<p>草稿箱<br>很多时候我们需要先写成草稿，而暂时不发布出去。draft page就可以满足我们的要求，我们的网站上是看不到草稿文件的。</p>
<p>//新建草稿文件hexo new draft b//预览草稿文件hexo server –draft//发布草稿hexo publish b</p>
<h4 id="八、新建页面"><a href="#八、新建页面" class="headerlink" title="八、新建页面"></a>八、新建页面</h4><p>有时我们不满足主题自由的一些页面，希望自己添加一些页面。</p>
<p>我们可以新建页面,新建页面则会在hexo的source中新建该页面文件并生成md文件，这就是你要编辑的博客页了。</p>
<p><code>hexo new page &quot;resouces&quot;</code></p>
<p>然后打开主题的配置文件_config.yml，在菜单属性menu中的添加如下（注意不是Hexo的配置文件）</p>
<p>将页面路径联接到页面上去</p>
<p>菜单自定义名称：/生成的页面名称</p>
<p><img src="/2022/08/14/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/14.png"></p>
<p>当我们点击资源时后会跳转到我们自定义的博客页了</p>
<h4 id="九、常见问题"><a href="#九、常见问题" class="headerlink" title="九、常见问题"></a>九、常见问题</h4><h5 id="1-文章插入图片"><a href="#1-文章插入图片" class="headerlink" title="1.文章插入图片"></a>1.文章插入图片</h5><p>1.设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true<br>安装插件:<code>npm install https://github.com/CodeFalling/hexo-asset-image -- save</code><br>运行hexo n “XXXXXX”,生成XXXXX.md博文时就会在/source/_posts目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。<br>添加图片:在想添加的位置写入<code>![](图片名字),例如![](1.png)</code>。</p>
<h5 id="2-文章内跳转另一篇文章"><a href="#2-文章内跳转另一篇文章" class="headerlink" title="2.文章内跳转另一篇文章"></a>2.文章内跳转另一篇文章</h5><p><code>&#123;%post_link 文章名称(不加后缀) 显示文字%&#125;</code></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>配置ssh</title>
    <url>/2022/08/18/%E9%85%8D%E7%BD%AEssh/</url>
    <content><![CDATA[<p>1.生成ssh公钥</p>
<p><code>ssh-keygen -t rsa</code></p>
<p>回车</p>
<p>2.获取公钥</p>
<p><code>cat ~/.ssh/id_rsa.pub</code></p>
<p>3.gitee或github设置账户公钥</p>
<p>gitee:设置    安全设置    SSH公钥</p>
<p>github:setting    SSH and GPG keys   new ssh key</p>
<p>4.验证是否成功</p>
<p><code>ssh -T git@gitee.com</code></p>
<p><code>ssh -T git@github.com</code></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
